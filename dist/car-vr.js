/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Init.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Car/CarBody.ts":
/*!****************************!*\
  !*** ./src/Car/CarBody.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar CarWheels_1 = __webpack_require__(/*! ./CarWheels */ \"./src/Car/CarWheels.ts\");\nvar CarLights_1 = __webpack_require__(/*! ./CarLights */ \"./src/Car/CarLights.ts\");\n\nvar CarBody = function () {\n\n  function CarBody(_scene, _cargo) {\n    this.parent = _scene;\n\n    this.carWhole = new THREE.Group();\n    this.carWhole.rotateY(-Math.PI / 2);\n\n    this.parent.add(this.carWhole);\n    this.carChassis = this.buildCarChassis(_cargo['vrBodyCompiled'], _cargo['envReflection']);\n    this.carWhole.add(this.carChassis);\n    this.addShadow(_cargo['shadow']);\n\n    this.carLights = new CarLights_1.default(this.carChassis, _cargo);\n    this.carWheels = new CarWheels_1.default(this.carWhole, _cargo);\n  }\n\n  CarBody.prototype.buildCarChassis = function (_bodyGeom, _cubeText) {\n    _bodyGeom.scale.set(0.0005, 0.0005, 0.0005);\n    _bodyGeom.position.set(1.56, 0, 0);\n    this.envCube = _cubeText;\n    this.envCube.format = THREE.RGBFormat;\n    this.matBodySilver = new THREE.MeshStandardMaterial({\n      color: 0xff5e57,\n      metalness: 0.7,\n      roughness: 0.7,\n      envMap: this.envCube\n    });\n\n    if (window['EXT_STLOD_SUPPORT'] === false) {\n      this.envCube.minFilter = THREE.LinearFilter;\n      this.matBodySilver.metalness = 0.05;\n      this.matBodySilver.roughness = 0.8;\n      this.matBodySilver.color = new THREE.Color(0x777777);\n    }\n\n    this.matBodyBlack = new THREE.MeshLambertMaterial({\n      color: 0x2D3436,\n      emissive: 0x444444,\n      reflectivity: 0.8,\n      envMap: this.envCube\n    });\n\n    this.matGlassTinted = new THREE.MeshLambertMaterial({\n      color: 0x000000,\n      emissive: 0x666666,\n      reflectivity: 1,\n      envMap: this.envCube\n    });\n\n    this.matUndercarriage = new THREE.MeshBasicMaterial({\n      color: 0x000000\n    });\n\n    this.matGlassTransp = new THREE.MeshLambertMaterial({\n      color: 0x000000,\n      emissive: 0x666666,\n      reflectivity: 1,\n      envMap: this.envCube,\n      transparent: true,\n      blending: THREE.AdditiveBlending\n    });\n\n    _bodyGeom.getObjectByName('BodyBlack').material = this.matBodyBlack;\n    _bodyGeom.getObjectByName('BodySilver').material = this.matBodySilver;\n    _bodyGeom.getObjectByName('GlassTransparent').material = this.matGlassTransp;\n    _bodyGeom.getObjectByName('GlassTinted').material = this.matGlassTinted;\n    _bodyGeom.getObjectByName('Undercarriage').material = this.matUndercarriage;\n\n    return _bodyGeom;\n  };\n\n  CarBody.prototype.addShadow = function (_shad) {\n    var shadowPlane = new THREE.PlaneBufferGeometry(6.5, 6.5, 1, 1);\n    shadowPlane.rotateX(-Math.PI / 2);\n    shadowPlane.translate(1.56, 0, 0);\n\n    var shadowMat = new THREE.MeshBasicMaterial({\n      map: _shad,\n      side: THREE.DoubleSide,\n      blending: THREE.MultiplyBlending,\n      transparent: true,\n      depthWrite: false\n    });\n\n    var shadowMesh = new THREE.Mesh(shadowPlane, shadowMat);\n    this.carWhole.add(shadowMesh);\n  };\n\n  CarBody.prototype.onWindowResize = function (_vpH) {\n    this.carLights.onWindowResize(_vpH);\n  };\n\n  CarBody.prototype.update = function (_props) {\n    this.carWhole.rotation.y = _props.theta;\n    this.carChassis.rotation.z = _props.longitMomentum * 0.0015;\n    this.carChassis.rotation.x = _props.lateralMomentum * 0.002;\n    this.carWheels.update(_props);\n    this.carLights.update(_props);\n  };\n  return CarBody;\n}();\n\nexports.default = CarBody;\n\n//# sourceURL=webpack:///./src/Car/CarBody.ts?");

/***/ }),

/***/ "./src/Car/CarLights.ts":
/*!******************************!*\
  !*** ./src/Car/CarLights.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar headgridVS = __webpack_require__(/*! ../Shaders/HeadGridVS */ \"./src/Shaders/HeadGridVS.ts\");\nvar headgridFS = __webpack_require__(/*! ../Shaders/headgridFS */ \"./src/Shaders/headgridFS.ts\");\nvar tailLightVS = __webpack_require__(/*! ../Shaders/tailLightVS */ \"./src/Shaders/tailLightVS.ts\");\nvar tailGridVS = __webpack_require__(/*! ../Shaders/tailGridVS */ \"./src/Shaders/tailGridVS.ts\");\nvar tailGridFS = __webpack_require__(/*! ../Shaders/tailGridFS */ \"./src/Shaders/tailGridFS.ts\");\nvar flareVS = __webpack_require__(/*! ../Shaders/FlareVS */ \"./src/Shaders/FlareVS.ts\");\nvar flareFS = __webpack_require__(/*! ../Shaders/FlareFS */ \"./src/Shaders/FlareFS.ts\");\nvar turnBarVS = __webpack_require__(/*! ../Shaders/turnBarVS */ \"./src/Shaders/turnBarVS.ts\");\nvar reverseBarVS = __webpack_require__(/*! ../Shaders/reverseBarVS */ \"./src/Shaders/reverseBarVS.ts\");\nvar reverseGridFS = __webpack_require__(/*! ../Shaders/ReverseGridFS */ \"./src/Shaders/ReverseGridFS.ts\");\nvar stopBarVS = __webpack_require__(/*! ../Shaders/stopBarVS */ \"./src/Shaders/stopBarVS.ts\");\nvar turnBarFS = __webpack_require__(/*! ../Shaders/turnBarFS */ \"./src/Shaders/turnBarFS.ts\");\n\nvar CarLights = function () {\n  function CarLights(_carChassis, _cargo) {\n    this.lfTimer = 0;\n    this.rtTimer = 0;\n    this.carChassis = _carChassis;\n    this.flareHeadText = _cargo['flareHead'];\n    this.flareTurnText = _cargo['flareTurn'];\n    this.glowTurnText = _cargo['lightTurn'];\n    this.glowStopText = _cargo['lightStop'];\n    this.glowReverseText = _cargo['lightReverse'];\n    this.uniLightsTurn = new THREE.Vector3(0, 0, 0);\n    this.uniLightsOther = new THREE.Vector3(0, 1, 0);\n    this.initLightMeshes();\n    this.initHeadlightFlares();\n    this.initStopFlares();\n    this.initReverseFlares();\n    this.initTurnFlares();\n  }\n\n  CarLights.prototype.initLightMeshes = function () {\n    var tailGrid = this.carChassis.getObjectByName('TailGrid');\n\n    tailGrid.geometry.computeVertexNormals();\n\n    this.matHeadLights = new THREE.ShaderMaterial({\n      uniforms: {\n        lightsT: {\n          value: this.uniLightsTurn\n        },\n        lightsO: {\n          value: this.uniLightsOther\n        }\n      },\n      vertexShader: headgridVS,\n      fragmentShader: headgridFS\n    });\n\n    this.matTailLights = new THREE.ShaderMaterial({\n      uniforms: {\n        lightsT: {\n          value: this.uniLightsTurn\n        },\n        lightsO: {\n          value: this.uniLightsOther\n        }\n      },\n      vertexShader: tailLightVS,\n      fragmentShader: tailGridFS\n    });\n\n    this.matTailGrid = new THREE.ShaderMaterial({\n      uniforms: {\n        lightsT: {\n          value: this.uniLightsTurn\n        },\n        lightsO: {\n          value: this.uniLightsOther\n        }\n      },\n      vertexShader: tailGridVS,\n      fragmentShader: tailGridFS\n    });\n\n    this.carChassis.getObjectByName('HeadLights').material = this.matHeadLights;\n    this.carChassis.getObjectByName('TailLights').material = this.matTailLights;\n    tailGrid.material = this.matTailGrid;\n  };\n\n  CarLights.prototype.initHeadlightFlares = function () {\n    this.flareHeadMat = new THREE.ShaderMaterial({\n      uniforms: {\n        texture: {\n          value: this.flareHeadText\n        },\n        vpH: {\n          value: window.innerHeight\n        },\n        size: {\n          value: 1.5\n        },\n        brightness: {\n          value: 1\n        }\n      },\n      vertexShader: flareVS,\n      fragmentShader: flareFS,\n      blending: THREE.AdditiveBlending,\n      transparent: true,\n      depthTest: false\n    });\n\n    var posArray = new Float32Array([\n      4000,\n      1875,\n      1700,\n      4300,\n      1800,\n      1700,\n      4000,\n      1875,\n      -1700,\n      4300,\n      1800,\n      -1700\n    ]);\n\n    var normArray = new Float32Array([\n      0.87,\n      0.22,\n      0.44,\n      0.87,\n      0.22,\n      0.44,\n      0.87,\n      0.22,\n      -0.44,\n      0.87,\n      0.22,\n      -0.44\n    ]);\n\n    this.flareHeadGeom = new THREE.BufferGeometry();\n    this.flareHeadGeom.addAttribute('position', new THREE.BufferAttribute(posArray, 3));\n    this.flareHeadGeom.addAttribute('normal', new THREE.BufferAttribute(normArray, 3));\n    this.flareHeadPoints = new THREE.Points(this.flareHeadGeom, this.flareHeadMat);\n    this.carChassis.add(this.flareHeadPoints);\n  };\n\n  CarLights.prototype.initStopFlares = function () {\n    var glowStopMat = new THREE.ShaderMaterial({\n      uniforms: {\n        texture: {\n          value: this.glowStopText\n        }\n      },\n      vertexShader: stopBarVS,\n      fragmentShader: turnBarFS,\n      blending: THREE.AdditiveBlending,\n      transparent: true,\n      depthTest: false\n    });\n\n    this.glowStop = this.carChassis.getObjectByName('Stop');\n    this.glowStop.material = glowStopMat;\n  };\n\n  CarLights.prototype.initReverseFlares = function () {\n    var glowReverseMat = new THREE.ShaderMaterial({\n      uniforms: {\n        texture: {\n          value: this.glowReverseText\n        }\n      },\n      vertexShader: reverseBarVS,\n      fragmentShader: reverseGridFS,\n      blending: THREE.AdditiveBlending,\n      transparent: true,\n      depthTest: false\n    });\n\n    this.glowReverse = this.carChassis.getObjectByName('Reverse');\n    this.glowReverse.material = glowReverseMat;\n  };\n\n  CarLights.prototype.initTurnFlares = function () {\n    var posArray = new Float32Array([\n      -4755,\n      2227,\n      -1269,\n      -4703,\n      2222,\n      -1326,\n      -4649,\n      2215,\n      -1381,\n      -4590,\n      2208,\n      -1436,\n      -4526,\n      2200,\n      -1492,\n      -4459,\n      2192,\n      -1548,\n      -4386,\n      2182,\n      -1604,\n      -4718,\n      2182,\n      -1264,\n      -4668,\n      2179,\n      -1321,\n      -4301,\n      2175,\n      -1658,\n      -4614,\n      2175,\n      -1377,\n      -4556,\n      2168,\n      -1433,\n      -4494,\n      2163,\n      -1489,\n      -4429,\n      2158,\n      -1545,\n      -4358,\n      2151,\n      -1600,\n      -4266,\n      2147,\n      -1653,\n      -4675,\n      2136,\n      -1260,\n      -4627,\n      2134,\n      -1316,\n      -4575,\n      2132,\n      -1373,\n      -4520,\n      2130,\n      -1428,\n      -4461,\n      2128,\n      -1485,\n      -4400,\n      2126,\n      -1540,\n      -4329,\n      2123,\n      -1597\n    ]);\n\n    var normArray = new Float32Array([\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4,\n      -0.9,\n      0,\n      -0.4\n    ]);\n\n    this.flareTurnMat = this.flareHeadMat.clone();\n    this.flareTurnMat.uniforms['texture'].value = this.flareTurnText;\n    this.flareTurnMat.uniforms['size'].value = 0.05;\n    this.flareTurnMat.uniforms['brightness'].value = 1;\n\n    var leftTurnGrid = new THREE.BufferGeometry();\n\n    leftTurnGrid.addAttribute('position', new THREE.BufferAttribute(posArray, 3));\n    leftTurnGrid.addAttribute('normal', new THREE.BufferAttribute(normArray, 3));\n\n    this.flareLPoints = new THREE.Points(leftTurnGrid, this.flareTurnMat);\n    this.carChassis.add(this.flareLPoints);\n\n    posArray = new Float32Array([\n      -4755,\n      2227,\n      1269,\n      -4703,\n      2222,\n      1326,\n      -4649,\n      2215,\n      1381,\n      -4590,\n      2208,\n      1436,\n      -4526,\n      2200,\n      1492,\n      -4459,\n      2192,\n      1548,\n      -4386,\n      2182,\n      1604,\n      -4718,\n      2182,\n      1264,\n      -4668,\n      2179,\n      1321,\n      -4301,\n      2175,\n      1658,\n      -4614,\n      2175,\n      1377,\n      -4556,\n      2168,\n      1433,\n      -4494,\n      2163,\n      1489,\n      -4429,\n      2158,\n      1545,\n      -4358,\n      2151,\n      1600,\n      -4266,\n      2147,\n      1653,\n      -4675,\n      2136,\n      1260,\n      -4627,\n      2134,\n      1316,\n      -4575,\n      2132,\n      1373,\n      -4520,\n      2130,\n      1428,\n      -4461,\n      2128,\n      1485,\n      -4400,\n      2126,\n      1540,\n      -4329,\n      2123,\n      1597\n    ]);\n\n    normArray = new Float32Array([\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4,\n      -0.9,\n      0,\n      0.4\n    ]);\n\n    var rightTurnGrid = new THREE.BufferGeometry();\n\n    rightTurnGrid.addAttribute('position', new THREE.BufferAttribute(posArray, 3));\n    rightTurnGrid.addAttribute('normal', new THREE.BufferAttribute(normArray, 3));\n\n    this.flareRPoints = new THREE.Points(rightTurnGrid, this.flareTurnMat);\n    this.carChassis.add(this.flareRPoints);\n\n    this.glowTurnMat = new THREE.ShaderMaterial({\n      uniforms: {\n        texture: {\n          value: this.glowTurnText\n        },\n        lightsT: {\n          value: this.uniLightsTurn\n        }\n      },\n      vertexShader: turnBarVS,\n      fragmentShader: turnBarFS,\n      blending: THREE.AdditiveBlending,\n      transparent: true,\n      depthTest: false\n    });\n\n    this.carChassis.getObjectByName('Turn').material = this.glowTurnMat;\n  };\n\n  CarLights.prototype.onWindowResize = function (_vpH) {\n    this.flareHeadMat.uniforms['vpH'].value = _vpH;\n    this.flareTurnMat.uniforms['vpH'].value = _vpH;\n  };\n\n  CarLights.prototype.update = function (_props) {\n    if (_props.wAngleTarg > 0) {\n      this.lfTimer = (this.lfTimer + _props.time.delta * 2) % 2;\n      this.uniLightsTurn.y = this.lfTimer > 1 ? 0 : 1;\n      this.uniLightsTurn.z = 0;\n      this.uniLightsTurn.x = -1;\n    } else if (_props.wAngleTarg < 0) {\n      this.rtTimer = (this.rtTimer + _props.time.delta * 2) % 2;\n      this.uniLightsTurn.z = this.rtTimer > 1 ? 0 : 1;\n      this.uniLightsTurn.y = 0;\n      this.uniLightsTurn.x = 1;\n    } else {\n      this.lfTimer = 0;\n      this.rtTimer = 0;\n      this.uniLightsTurn.y = 0;\n      this.uniLightsTurn.z = 0;\n      this.uniLightsTurn.x = 0;\n    }\n\n    this.uniLightsOther.x = 0;\n    this.glowStop.visible = _props.braking ? true : false;\n    this.glowReverse.visible = _props.gear == -1 ? true : false;\n    this.flareLPoints.visible = this.uniLightsTurn.y ? true : false;\n    this.flareRPoints.visible = this.uniLightsTurn.z ? true : false;\n  };\n\n  return CarLights;\n}();\n\nexports.default = CarLights;\n\n//# sourceURL=webpack:///./src/Car/CarLights.ts?");

/***/ }),

/***/ "./src/Car/CarProps.ts":
/*!*****************************!*\
  !*** ./src/Car/CarProps.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils_1 = __webpack_require__(/*! ../Utility/Utils */ \"./src/Utility/Utils.ts\");\n\nvar Automotive = function () {\n  function Automotive() {}\n  Automotive.Force = 1800;\n  Automotive.Accel = 10;\n  Automotive.Decel = -5;\n  Automotive.MaxVel = 70 * 1610 / 3600;\n  Automotive.MaxTurn = Math.PI * 0.33;\n  Automotive.Length = 5.25;\n  Automotive.Width = 2.283;\n  Automotive.WheelTrack = 1.72;\n  Automotive.WheelBase = 3.2;\n  Automotive.WheelDiam = 0.78;\n  Automotive.WheelCirc = Automotive.WheelDiam * Math.PI;\n  Automotive.Weight = 3198;\n  return Automotive;\n}();\n\nexports.Automotive = Automotive;\n\nvar CarProps = function () {\n  function CarProps() {\n    this.time = new utils_1.Time();\n    this.velocity = new THREE.Vector2();\n    this.speed = 0;\n    this.accel = 0;\n    this.gear = 1;\n    this.pos = new THREE.Vector2();\n    this.joyVec = new THREE.Vector2();\n\n    // Momentum\n    this.longitMomentum = 0;\n    this.lateralMomentum = 0;\n    this.wAngleInner = 0;\n    this.wAngleOuter = 0;\n    this.wAngleTarg = 0;\n    this.keys = new Array();\n    this.braking = 0;\n    this.omega = 0;\n    this.theta = -Math.PI / 2;\n  }\n\n  CarProps.prototype.onKeyDown = function (evt) {\n    // Add key to list if they don't exist yet\n    if (this.keys.indexOf(evt.keyCode) === -1)\n      this.keys.push(evt.keyCode);\n  };\n\n  CarProps.prototype.onKeyUp = function (evt) {\n    //Otherwise, remove from keys list\n    this.keys.splice(this.keys.indexOf(evt.keyCode), 1);\n  };\n\n  CarProps.prototype.readKeyboardInput = function () {\n    for (var i = 0; i < this.keys.length; i++) {\n      switch (this.keys[i]) {\n\n        case 17: // CTRL - Shift Down\n          if ((this.speed * 3.6) < 5.314815 && this.gear != -1) {\n            this.gear = -1;\n          } else {\n            if (this.gear > 0)\n              this.gear--;\n          }\n          break;\n\n        case 16: // SHIFT - Shift Up\n          if (this.gear == -1 && this.speed * 3.6 < 5.314815)\n            this.gear++;\n          if (this.gear > 0 && this.gear < 6)\n            this.gear++;\n\n          break;\n\n        case 38: // Up\n          if (this.gear > -1) {\n            this.accel += Automotive.Accel;\n\n            // Simulate wind resistance as we reach top speed\n            this.accel *= utils_1.normalizeQuadIn(this.speed, Automotive.MaxVel, Automotive.MaxVel - 10);\n          } else {\n            this.accel += Automotive.Decel / 1.2;\n            this.braking = 1;\n          }\n\n          break;\n\n        case 40: // Down\n          if (this.gear == -1) {\n            this.accel += Automotive.Accel;\n            this.accel *= utils_1.normalizeQuadIn(this.speed, Automotive.MaxVel / Math.PI, Automotive.MaxVel / Math.PI - 10);\n          } else {\n            this.accel += Automotive.Decel / 1.2;\n            this.braking = 1;\n          }\n\n          break;\n\n        case 32: // Space\n          this.accel += Automotive.Decel;\n          this.braking = 1;\n\n          break;\n\n        case 37: { // Left\n          const omegaAxle = 0.6;\n          const omegaMg = 0.4;\n\n          /*!  \n           *  Variables:\n           *      F - Friction\n           *      m - Weight\n           *      g - acceleration\n           *      R - Axle Force\n           *      W - Number of Wheels\n           *      F^fr^max - ~decceleration\n           * \n           *  Constants:\n           *      u^s = 0.6\n           *      u^k = 0.4\n           * \n           *  Formula:\n           *      F = (((m / R) * g) * u^s * u^k) - 4) * F^fr^max\n           *      \n           */\n          const decceleration = (Automotive.Weight / Automotive.Force * Automotive.Accel * omegaAxle * omegaMg - 4) * Automotive.Decel;\n          \n          this.accel += decceleration - Automotive.MaxTurn;\n\n          this.wAngleTarg += Automotive.MaxTurn;\n\n          break;\n        }\n\n        case 39: { // Right\n\n          const omegaAxle = 0.6;\n          const omegaMg = 0.4;\n          const decceleration = (Automotive.Weight / Automotive.Force * Automotive.Accel * omegaAxle * omegaMg - 4) * Automotive.Decel;\n          \n          this.accel += decceleration - Automotive.MaxTurn;\n\n          this.wAngleTarg -= Automotive.MaxTurn;\n\n          break;\n        }\n      }\n    }\n  };\n\n  CarProps.prototype.onJoystickMove = function (_vec) {\n    this.joyVec.x = _vec.x / -40;\n    this.joyVec.y = _vec.y / -40;\n\n    if (Math.abs(this.joyVec.x) > 0.85) {\n      this.joyVec.y = 0;\n    }\n\n    if (Math.abs(this.joyVec.y) > 0.95) {\n      this.joyVec.x = 0;\n    }\n  };\n\n  CarProps.prototype.readJoyStickInput = function () {\n    this.wAngleTarg = this.joyVec.x * Automotive.MaxTurn;\n\n    //Accelerating\n    if (this.joyVec.y >= 0) {\n      this.accel = this.joyVec.y * Automotive.Accel;\n\n      // Simulate wind resistance as we reach top speed\n      this.accel *= utils_1.normalizeQuadIn(this.speed, Automotive.MaxVel, Automotive.MaxVel - 10);\n      \n      this.braking = 0;\n    } else {\n      this.accel = this.joyVec.y * -Automotive.Decel;\n     \n      this.braking = 1;\n    }\n  };\n\n  /////////////////////////////// UPDATE ///////////////////////////////\n  CarProps.prototype.update = function (_time) {\n    // Update time, skips according to FPS\n    if (this.time.update(_time) === false) {\n      return false;\n    }\n\n    this.accel = 0;\n    this.braking = 0;\n    this.wAngleTarg = 0;\n\n    if (this.keys.length > 0) {\n      this.readKeyboardInput();\n    } else if (this.joyVec.x != 0 || this.joyVec.y != 0) {\n      this.readJoyStickInput();\n    } else if (this.keys.length == 0) {\n      const omegaAxle = 0.6;\n      const omegaMg = 0.4;\n      \n      const decceleration = (Automotive.Weight / Automotive.Force * Automotive.Accel * omegaAxle * omegaMg - 4) * Automotive.Decel;\n      \n      this.accel += decceleration;\n    }\n\n    this.accel *= this.time.delta;\n    this.speed += this.accel;\n\n    let speedometer = document.getElementsByClassName('speedometerSpeed');\n    speedometer[0].innerHTML = Math.round(parseInt((this.speed * 3.6).toString())).toString();\n    \n    ///////////////// PHYSICS, YO! /////////////////\n    if (this.speed < 0) {\n      this.speed = 0;\n      this.accel = 0;\n    }\n\n    this.frameDist = this.speed * this.time.delta;\n\n    // Limit turn angle as speed increases\n    this.wAngleTarg *= utils_1.normalizeQuadIn(this.speed, Automotive.MaxVel + 10, 3);\n    this.wAngleInner = utils_1.zTween(this.wAngleInner, this.wAngleTarg, this.time.delta * 2);\n    this.wAngleSign = this.wAngleInner > 0.001 ? 1 : this.wAngleInner < -0.001 ? -1 : 0;\n\n    // Theta is based on speed, wheelbase & wheel angle\n    this.omega = this.wAngleInner * this.speed / Automotive.WheelBase;\n\n    if(this.gear == -1) \n      this.theta -= this.omega * this.time.delta;\n    else\n      this.theta += this.omega * this.time.delta;\n\n    if (this.gear > -1) {\n      // Calc this frame's XY velocity\n      this.velocity.set(Math.cos(this.theta) * this.frameDist, -Math.sin(this.theta) * this.frameDist);\n      \n      // Add velocity to total position\n      this.pos.add(this.velocity);\n    } else {\n      \n      // Calc this frame's XY velocity\n      this.velocity.set(-Math.cos(this.theta) * this.frameDist, Math.sin(this.theta) * this.frameDist);\n\n      // Add velocity to total position\n      this.pos.add(this.velocity);\n    }\n\n    // Fake some momentum\n    this.longitMomentum = utils_1.zTween(this.longitMomentum, this.accel / this.time.delta, this.time.delta * 6);\n    this.lateralMomentum = this.omega * this.speed;\n\n    if (this.wAngleSign) {\n        // Calculate 4 wheel turning radius if angle\n        this.radFrontIn = Automotive.WheelBase / Math.sin(this.wAngleInner);\n        this.radBackIn = Automotive.WheelBase / Math.tan(this.wAngleInner);\n        this.radBackOut = this.radBackIn + Automotive.WheelTrack * this.wAngleSign;\n        this.wAngleOuter = Math.atan(Automotive.WheelBase / this.radBackOut);\n        this.radFrontOut = Automotive.WheelBase / Math.sin(this.wAngleOuter);\n    } else {\n      // Otherwise, just assign a very large radius.\n      this.radFrontOut = 100;\n      this.radBackOut = 100;\n      this.radBackIn = 100;\n      this.radFrontIn = 100;\n      this.wAngleOuter = 0;\n    }\n\n    return true;\n  };\n\n  return CarProps;\n}();\n\nexports.CarProps = CarProps;\n\n//# sourceURL=webpack:///./src/Car/CarProps.ts?");

/***/ }),

/***/ "./src/Car/CarWheels.ts":
/*!******************************!*\
  !*** ./src/Car/CarWheels.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar CarProps_1 = __webpack_require__(/*! ./CarProps */ \"./src/Car/CarProps.ts\");\nvar utils_1 = __webpack_require__(/*! ../Utility/Utils */ \"./src/Utility/Utils.ts\");\n\nvar CarWheels = function () {\n  function CarWheels(_carWhole, _cargo) {\n    this.maxWheelTurn = Math.PI / 9.69;\n\n    this.parent = _carWhole;\n    this.thread = _cargo['thread'];\n\n    this.thread.minFilter = THREE.NearestFilter;\n    this.thread.magFilter = THREE.LinearFilter;\n    \n    this.thread.format = THREE.RGBFormat;\n   \n    this.ogMatrix = new THREE.Matrix4().set(0.000788, 0, 0, -0.3939, 0, 0, 0.000788, -0.3939, 0, -0.000788, 0, 0.15, 0, 0, 0, 1);\n    this.invMatrix = new THREE.Matrix4().set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1);\n   \n    this.wPosF = CarProps_1.Automotive.WheelBase;\n    this.wPosB = 0;\n    this.wPosL = CarProps_1.Automotive.WheelTrack / -2;\n    this.wPosR = CarProps_1.Automotive.WheelTrack / 2;\n    this.wPosY = CarProps_1.Automotive.WheelDiam / 2;\n\n    var wheelGeom = _cargo['vrWheelBrakes'];\n\n    this.addLeftWheels(wheelGeom.getObjectByName('Wheel'));\n    this.addRightWheels();\n    this.addBrakes(wheelGeom.getObjectByName('Brake'));\n  }\n\n  CarWheels.prototype.addLeftWheels = function (_wheelGroup) {\n    this.wheelFL = _wheelGroup;\n\n    this.meshRubber = this.wheelFL.getObjectByName('Tire');\n    this.meshSilver = this.wheelFL.getObjectByName('RimsSilver');\n    this.meshBlack = this.wheelFL.getObjectByName('RimsBlack');\n\n    this.geomRubber = this.meshRubber.geometry;\n    this.geomSilver = this.meshSilver.geometry;\n    this.geomBlack = this.meshBlack.geometry;\n\n    this.geomRubber.applyMatrix(this.ogMatrix);\n    this.geomSilver.applyMatrix(this.ogMatrix);\n    this.geomBlack.applyMatrix(this.ogMatrix);\n\n    this.geomRubber.computeVertexNormals();\n    this.geomSilver.computeVertexNormals();\n    this.geomBlack.computeVertexNormals();\n\n    this.matRubber = new THREE.MeshLambertMaterial({\n      color: 0x202020,\n      map: this.thread\n    });\n\n    this.matSilver = new THREE.MeshPhongMaterial({\n      color: 0x999999,\n      shininess: 50\n    });\n\n    this.matBlack = new THREE.MeshPhongMaterial({\n      color: 0x111111,\n      shininess: 50\n    });\n\n    this.meshRubber.material = this.matRubber;\n    this.meshSilver.material = this.matSilver;\n    this.meshBlack.material = this.matBlack;\n\n    this.wheelFL.position.set(this.wPosF, this.wPosY, this.wPosL);\n\n    this.parent.add(this.wheelFL);\n\n    this.wheelBL = this.wheelFL.clone();\n    this.wheelBL.position.set(this.wPosB, this.wPosY, this.wPosL);\n\n    this.parent.add(this.wheelBL);\n  };\n\n  CarWheels.prototype.addRightWheels = function () {\n    this.iGeomRubber = this.geomRubber.clone();\n    this.iGeomSilver = this.geomSilver.clone();\n    this.iGeomBlack = this.geomBlack.clone();\n\n    this.iGeomRubber.applyMatrix(this.invMatrix);\n    this.iGeomSilver.applyMatrix(this.invMatrix);\n    this.iGeomBlack.applyMatrix(this.invMatrix);\n\n    this.iGeomRubber.computeVertexNormals();\n    this.iGeomSilver.computeVertexNormals();\n    this.iGeomBlack.computeVertexNormals();\n\n    var iMatRubber = this.matRubber.clone();\n    var iMatSilver = this.matSilver.clone();\n    var iMatBlack = this.matBlack.clone();\n\n    iMatRubber.side = THREE.BackSide;\n    iMatSilver.side = THREE.BackSide;\n    iMatBlack.side = THREE.BackSide;\n\n    this.iMeshRubber = new THREE.Mesh(this.iGeomRubber, iMatRubber);\n    this.iMeshSilver = new THREE.Mesh(this.iGeomSilver, iMatSilver);\n    this.iMeshBlack = new THREE.Mesh(this.iGeomBlack, iMatBlack);\n\n    this.wheelFR = new THREE.Group();\n    this.wheelFR.add(this.iMeshRubber);\n    this.wheelFR.add(this.iMeshSilver);\n    this.wheelFR.add(this.iMeshBlack);\n\n    this.wheelFR.position.set(this.wPosF, this.wPosY, this.wPosR);\n    this.parent.add(this.wheelFR);\n\n    this.wheelBR = this.wheelFR.clone();\n\n    this.wheelBR.position.set(this.wPosB, this.wPosY, this.wPosR);\n    this.parent.add(this.wheelBR);\n  };\n\n  CarWheels.prototype.addBrakes = function (_brakeGroup) {\n    this.brakeBL = _brakeGroup;\n\n    this.brMeshDisc = this.brakeBL.getObjectByName('Disc');\n    this.brMeshPads = this.brakeBL.getObjectByName('Pad');\n\n    this.brGeomDisc = this.brMeshDisc.geometry;\n    this.brGeomPads = this.brMeshPads.geometry;\n\n    this.brGeomDisc.applyMatrix(this.ogMatrix);\n    this.brGeomPads.applyMatrix(this.ogMatrix);\n\n    this.brGeomDisc.computeVertexNormals();\n    this.brGeomPads.computeVertexNormals();\n\n    this.brMatDisc = new THREE.MeshPhongMaterial({\n      color: 0x555555,\n      shininess: 100,\n      shading: THREE.FlatShading\n    });\n\n    this.brMatPads = new THREE.MeshPhongMaterial({\n      color: 0xD63031,\n      shininess: 50,\n      shading: THREE.FlatShading\n    });\n\n    this.brMeshDisc.material = this.brMatDisc;\n    this.brMeshPads.material = this.brMatPads;\n\n    this.brakeBL.position.set(this.wPosB, this.wPosY, this.wPosL);\n    this.parent.add(this.brakeBL);\n\n    this.brakeFL = this.brakeBL.clone();\n\n    this.brakeFL.position.set(this.wPosF, this.wPosY, this.wPosL);\n    this.brakeFL.rotation.set(0, 0, Math.PI);\n    this.parent.add(this.brakeFL);\n\n    this.brakeFR = this.brakeBL.clone();\n\n    this.brakeFR.position.set(this.wPosF, this.wPosY, this.wPosR);\n    this.brakeFR.rotation.set(Math.PI, 0, Math.PI);\n    this.parent.add(this.brakeFR);\n\n    this.brakeBR = this.brakeBL.clone();\n\n    this.brakeBR.position.set(this.wPosB, this.wPosY, this.wPosR);\n    this.brakeBR.rotation.set(Math.PI, 0, 0);\n    this.parent.add(this.brakeBR);\n\n  };\n\n  CarWheels.prototype.addHub = function (xPos, yPos, zPos) {\n    var geometry = new THREE.CylinderGeometry(0.15, 0.15, 0.03, 20);\n\n    geometry.rotateX(Math.PI / 2);\n\n    var material = new THREE.MeshPhongMaterial({\n      color: 0x333333,\n      shininess: 50\n    });\n\n    var hubSphere = new THREE.Mesh(geometry, material);\n\n    hubSphere.position.set(xPos, yPos, zPos);\n    this.parent.add(hubSphere);\n\n    return hubSphere;\n  };\n\n  CarWheels.prototype.turnByRadiusRatio = function (_props) {\n    this.rotOverall = -_props.frameDist / CarProps_1.Automotive.WheelCirc * Math.PI * 2;\n    this.rotFL = this.rotBL = this.rotFR = this.rotBR = Math.max(this.rotOverall, -this.maxWheelTurn);\n\n    if (_props.wAngleSign !== 0) {\n      this.ratioFO = _props.radFrontOut / _props.radBackIn;\n      this.ratioBO = _props.radBackOut / _props.radBackIn;\n      this.ratioFI = _props.radFrontIn / _props.radBackIn;\n      this.ratioBI = 1;\n\n      if (_props.wAngleSign == 1) {\n        this.rotFL *= this.ratioFI;\n        this.rotBL *= this.ratioBI;\n        this.rotFR *= this.ratioFO;\n        this.rotBR *= this.ratioBO;\n\n        this.wheelFL.rotation.y = _props.wAngleInner;\n        this.wheelFR.rotation.y = _props.wAngleOuter;\n        this.brakeFL.rotation.y = _props.wAngleInner;\n        this.brakeFR.rotation.y = -_props.wAngleOuter;\n      } else {\n        this.rotFL *= this.ratioFO;\n        this.rotBL *= this.ratioBO;\n        this.rotFR *= this.ratioFI;\n        this.rotBR *= this.ratioBI;\n        \n        this.wheelFL.rotation.y = _props.wAngleOuter;\n        this.wheelFR.rotation.y = _props.wAngleInner;\n        this.brakeFL.rotation.y = _props.wAngleOuter;\n        this.brakeFR.rotation.y = -_props.wAngleInner;\n      }\n\n      this.brakeBL.rotation.y = this.wheelBR.rotation.y = this.wheelBL.rotation.y = utils_1.normalize(_props.speed, 22.2, 0) * _props.wAngleInner * -0.09;\n      this.brakeBR.rotation.y = -this.wheelBL.rotation.y;\n    }\n\n    this.wheelFL.rotateZ(this.rotFL);\n    this.wheelBL.rotateZ(this.rotBL);\n    this.wheelFR.rotateZ(this.rotFR);\n    this.wheelBR.rotateZ(this.rotBR);\n  };\n\n  CarWheels.prototype.update = function (props) {\n    this.turnByRadiusRatio(props);\n  };\n\n  return CarWheels;\n}();\n\nexports.default = CarWheels;\n\n//# sourceURL=webpack:///./src/Car/CarWheels.ts?");

/***/ }),

/***/ "./src/Controls/CameraControl.ts":
/*!***************************************!*\
  !*** ./src/Controls/CameraControl.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar CamControl = function () {\n  function CamControl(options) {\n    this.options = {\n      fov: 45,\n      distance: 90,\n      distRange: {\n        max: Number.POSITIVE_INFINITY,\n        min: Number.NEGATIVE_INFINITY\n      },\n      focusPos: new THREE.Vector3(),\n      rotation: new THREE.Vector3(),\n      rotRange: {\n        xMax: Number.POSITIVE_INFINITY,\n        xMin: Number.NEGATIVE_INFINITY,\n        yMax: 90,\n        yMin: -90\n      },\n      eyeSeparation: 0\n    };\n    \n    for (var key in options) {\n      if (key === 'rotRange') {\n        for (var key in options.rotRange) {\n          this.options.rotRange[key] = options.rotRange[key];\n        }\n      } else if (key === 'distRange') {\n        for (var key in options.distRange) {\n          this.options.distRange[key] = options.distRange[key];\n        }\n      } else {\n        this.options[key] = options[key];\n      }\n    }\n\n    this.distActual = this.options.distance;\n    this.distTarget = this.options.distance;\n\n    this.focusActual = this.options.focusPos.clone();\n    this.focusTarget = this.options.focusPos.clone();\n\n    this.rotActual = this.options.rotation.clone();\n    this.rotTarget = this.options.rotation.clone();\n\n    var vpW = window.innerWidth;\n    var vpH = window.innerHeight;\n\n    this.camera = new THREE.PerspectiveCamera(this.options.fov, vpW / vpH, 0.1, 100);\n    this.radians = Math.PI / 180;\n    \n    this.quatX = new THREE.Quaternion();\n    this.quatY = new THREE.Quaternion();\n    \n    this.gyro = {\n      orient: 0\n    };\n\n    if (typeof window.orientation !== 'undefined') {\n      this.defaultEuler = new THREE.Euler(90 * this.radians, 180 * this.radians, (180 + parseInt(window.orientation.toString(), 10)) * this.radians);\n    } else {\n      this.defaultEuler = new THREE.Euler(0, 0, 0);\n    }\n  }\n\n  CamControl.prototype.setDistance = function (dist) {\n    if (dist === void 0) {\n      dist = 150;\n    }\n\n    this.distActual = dist;\n    this.distTarget = dist;\n  };\n\n  CamControl.prototype.setAngleRange = function (xMax, xMin, yMax, yMin) {\n    if (xMax === void 0) {\n      xMax = Number.POSITIVE_INFINITY;\n    }\n\n    if (xMin === void 0) {\n      xMin = Number.NEGATIVE_INFINITY;\n    }\n\n    if (yMax === void 0) {\n      yMax = 90;\n    }\n\n    if (yMin === void 0) {\n      yMin = -90;\n    }\n\n    this.options.rotRange.xMax = xMax;\n    this.options.rotRange.xMin = xMin;\n    this.options.rotRange.yMax = yMax;\n    this.options.rotRange.yMin = yMin;\n  };\n\n  CamControl.prototype.setRotation = function (_rotX, _rotY, _rotZ) {\n    if (_rotX === void 0) {\n      _rotX = 0;\n    }\n\n    if (_rotY === void 0) {\n      _rotY = 0;\n    }\n\n    if (_rotZ === void 0) {\n      _rotZ = 0;\n    }\n\n    this.rotActual.set(_rotX, _rotY, _rotZ);\n    this.rotTarget.set(_rotX, _rotY, _rotZ);\n\n    this.gyro.alpha = undefined;\n    this.gyro.beta = undefined;\n    this.gyro.gamma = undefined;\n  };\n\n  CamControl.prototype.setFocusPos = function (_posX, _posY, _posZ) {\n    if (_posX === void 0) {\n      _posX = 0;\n    }\n\n    if (_posY === void 0) {\n      _posY = 0;\n    }\n\n    if (_posZ === void 0) {\n      _posZ = 0;\n    }\n\n    this.focusActual.set(_posX, _posY, _posZ);\n    this.focusTarget.set(_posX, _posY, _posZ);\n  };\n\n  CamControl.prototype.dolly = function (distance) {\n    this.distTarget += distance / 100;\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\n  };\n\n  CamControl.prototype.orbitBy = function (angleX, angleY) {\n    this.rotTarget.x += angleX;\n    this.rotTarget.y += angleY;\n    this.rotTarget.x = THREE.Math.clamp(this.rotTarget.x, this.options.rotRange.xMin, this.options.rotRange.xMax);\n    this.rotTarget.y = THREE.Math.clamp(this.rotTarget.y, this.options.rotRange.yMin, this.options.rotRange.yMax);\n  };\n\n  CamControl.prototype.orbitTo = function (angleX, angleY) {\n    this.rotTarget.x = angleX;\n    this.rotTarget.y = angleY;\n    this.rotTarget.x = THREE.Math.clamp(this.rotTarget.x, this.options.rotRange.xMin, this.options.rotRange.xMax);\n    this.rotTarget.y = THREE.Math.clamp(this.rotTarget.y, this.options.rotRange.yMin, this.options.rotRange.yMax);\n  };\n\n  CamControl.prototype.pan = function (distX, distY) {\n    this.focusTarget.x -= distX / 10;\n    this.focusTarget.y += distY / 10;\n  };\n\n  CamControl.prototype.onWindowResize = function (vpW, vpH) {\n    this.camera.aspect = vpW / vpH;\n    this.camera.updateProjectionMatrix();\n  };\n\n  CamControl.prototype.onDeviceReorientation = function (orientation) {\n    this.gyro.orient = orientation * this.radians;\n  };\n  \n  CamControl.prototype.onGyroMove = function (alpha, beta, gamma) {\n    var acc = this.gyro;\n\n    acc.alpha = alpha;\n    acc.beta = beta;\n    acc.gamma = gamma;\n  };\n\n  CamControl.prototype.update = function () {\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\n    this.distActual += (this.distTarget - this.distActual) * 0.01;\n    \n    this.focusActual.lerp(this.focusTarget, 0.05);\n    this.camera.position.copy(this.focusActual);\n\n    if (this.gyro.alpha && this.gyro.beta && this.gyro.gamma) {\n      this.camera.setRotationFromEuler(this.defaultEuler);\n      \n      this.camera.rotateZ(this.gyro.alpha * this.radians);\n      this.camera.rotateX(this.gyro.beta * this.radians);\n      this.camera.rotateY(this.gyro.gamma * this.radians);\n\n      this.camera.rotation.z += this.gyro.orient;\n    } else {\n      this.rotActual.lerp(this.rotTarget, 0.05);\n\n      this.quatX.setFromAxisAngle(CamControl.axisX, -THREE.Math.degToRad(this.rotActual.y));\n      this.quatY.setFromAxisAngle(CamControl.axisY, -THREE.Math.degToRad(this.rotActual.x));\n      this.quatY.multiply(this.quatX);\n\n      this.camera.quaternion.copy(this.quatY);\n    }\n\n    this.camera.translateZ(this.distActual);\n  };\n\n  CamControl.prototype.follow = function (target) {\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\n    this.distActual += (this.distTarget - this.distActual) * 0.01;\n    \n    this.focusTarget.set(target.x, target.y + 1, target.z + this.distActual);\n    this.focusActual.lerp(this.focusTarget, 0.01);\n    \n    this.camera.position.copy(this.focusActual);\n    this.camera.lookAt(target);\n  };\n\n  CamControl.axisX = new THREE.Vector3(1, 0, 0);\n  CamControl.axisY = new THREE.Vector3(0, 1, 0);\n\n  return CamControl;\n}();\n\nexports.default = CamControl;\n\n//# sourceURL=webpack:///./src/Controls/CameraControl.ts?");

/***/ }),

/***/ "./src/Controls/Controls.ts":
/*!**********************************!*\
  !*** ./src/Controls/Controls.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Joystick_1 = __webpack_require__(/*! ./Joystick */ \"./src/Controls/Joystick.ts\");\nvar gimbal_1 = __webpack_require__(/*! ./Gimball */ \"./src/Controls/Gimball.ts\");\nvar model_1 = __webpack_require__(/*! ../Model */ \"./src/Model.ts\");\nvar raycaster_1 = __webpack_require__(/*! ../Utility/Raycaster */ \"./src/Utility/Raycaster.ts\");\nvar preloader_1 = __webpack_require__(/*! ../Preloader */ \"./src/Preloader.ts\");\n\nvar Controls = function () {\n  function Controls() {\n    this.introComplete = false;\n    this.modeVR = false;\n    this.modeOrbit = false;\n    this.deviceTouch = undefined;\n    this.deviceAccel = false;\n    this.zoom = 1;\n\n    TweenLite.defaultEase = Power2.easeInOut;\n\n    this.pageMain = document.getElementById('pageMain');\n    this.model = new model_1.default(this.pageMain);\n    this.mouseTap = new THREE.Vector2(1000, 1000);\n\n    this.hammer = new Hammer(this.pageMain);\n    this.refHammerPan = this.rippleTouch.bind(this);\n\n    this.hammer.get('pan').set({\n      direction: Hammer.DIRECTION_ALL,\n      threshold: 3\n    });\n    \n    this.hammer.on('hammer.input', this.refHammerPan);\n    window.addEventListener('resize', this.onWindowResize.bind(this), false);\n    \n    this.accelTestReference = this.acceleromTest.bind(this);\n    window.addEventListener('deviceorientation', this.accelTestReference);\n    \n    this.ray = new raycaster_1.default(this.model.monoc.camera);\n    this.preload();\n  }\n\n  Controls.prototype.preload = function () {\n    var manifesto = [\n      {\n        name: 'envReflection',\n        type: 'cubetexture',\n        ext: 'jpg'\n      },\n      {\n        name: 'envSkybox',\n        type: 'cubetexture',\n        ext: 'jpg'\n      },\n      {\n        name: 'flareHead',\n        type: 'texture',\n        ext: 'jpg'\n      },\n      {\n        name: 'flareTurn',\n        type: 'texture',\n        ext: 'jpg'\n      },\n      {\n        name: 'lightTurn',\n        type: 'texture',\n        ext: 'jpg'\n      },\n      {\n        name: 'lightStop',\n        type: 'texture',\n        ext: 'jpg'\n      },\n      {\n        name: 'lightReverse',\n        type: 'texture',\n        ext: 'jpg'\n      },\n      {\n        name: 'vrBodyCompiled',\n        type: 'mesh',\n        ext: 'json'\n      },\n      {\n        name: 'vrWheelBrakes',\n        type: 'mesh',\n        ext: 'json'\n      },\n      {\n        name: 'thread',\n        type: 'texture',\n        ext: 'jpg'\n      },\n      {\n        name: 'shadow',\n        type: 'texture',\n        ext: 'jpg'\n      },\n      {\n        name: 'icoBtns',\n        type: 'texture',\n        ext: 'png'\n      },\n      {\n        name: 'icoCtrls',\n        type: 'texture',\n        ext: 'png'\n      }\n    ];\n\n    var path = '';\n    this.preloader = new preloader_1.Preloader(path, manifesto, this);\n\n    window['preloader'] = this.preloader;\n\n    this.preloader.start();\n    this.model.introPreloading();\n  };\n\n  Controls.prototype.preloadComplete = function (_cargo) {\n    this.model.introPreloaded(_cargo);\n    this.introComplete = true;\n\n    this.refHammerTap = this.introAnimation.bind(this);\n    this.hammer.on('tap', this.refHammerTap);\n  };\n\n  Controls.prototype.introAnimation = function (evt) {\n    if (typeof this.deviceTouch === 'undefined') {\n      this.hammerCheckTouch(evt);\n    }\n\n    this.hammer.off('tap', this.refHammerTap);\n    this.hammer.off('hammer.input', this.refHammerPan);\n\n    this.model.introStart();\n    this.preloader.remove();\n\n    TweenLite.delayedCall(3, this.initControls.bind(this));\n  };\n\n  Controls.prototype.initControls = function (evt) {\n    this.joystick = new Joystick_1.default();\n    this.gimbal = new gimbal_1.default();\n\n    this.initKeyboard();\n    this.initButtons();\n    this.initHammer();\n    \n    this.pageMain.addEventListener('wheel', this.gestureWheel.bind(this));\n    \n    window.addEventListener('deviceorientation', this.accelerometerMove.bind(this));\n    window.addEventListener('orientationchange', this.onDeviceReorientation.bind(this));\n    \n    this.onDeviceReorientation();\n\n    this.mobHUDTilt = document.getElementById('mobileHUDTilt');\n    this.mobHUDTouch = document.getElementById('mobileHUDTouch');\n\n    if (this.deviceTouch === false) {\n      var ctrls = document.getElementsByClassName('ctrls');\n\n      for (var i = 0; i < ctrls.length; i++) {\n        ctrls[i].style.opacity = '1';\n      }\n    } else {\n      this.showHUD();\n    }\n  };\n\n  Controls.prototype.showHUD = function () {\n    this.mobHUDTilt.style.opacity = '1';\n    this.mobHUDTouch.style.opacity = '1';\n\n    TweenLite.delayedCall(3, this.hideHUD.bind(this));\n  };\n\n  Controls.prototype.hideHUD = function () {\n    this.mobHUDTilt.style.opacity = '0';\n    this.mobHUDTouch.style.opacity = '0';\n  };\n\n  Controls.prototype.rippleTouch = function (evt) {\n    if (evt.isFinal === false) {\n      this.raycast(evt);\n    }\n  };\n\n  Controls.prototype.hammerCheckTouch = function (evt) {\n    switch (evt.pointerType) {\n\n      case 'mouse':\n        this.deviceTouch = false;\n        break;\n\n      case 'touch':\n      default:\n        this.deviceTouch = true;\n        break;\n    }\n  };\n\n  Controls.prototype.initHammer = function () {\n    if (this.deviceTouch) {\n      this.hammer.get('pinch').set({ enable: true });\n      this.hammer.on('hammer.input', this.hammerInput.bind(this));\n      this.hammer.on('pinchstart', this.hammerPinchStart.bind(this));\n      this.hammer.on('pinch', this.hammerPinch.bind(this));\n    } else {\n      this.hammer.get('pan').set({\n        direction: Hammer.DIRECTION_ALL,\n        threshold: 1\n      });\n\n      this.hammer.on('pan', this.hammerPan.bind(this));\n    }\n  };\n\n  Controls.prototype.hammerPan = function (event) {\n    this.model.cam.orbitBy(event.velocityX, event.velocityY);\n  };\n\n  Controls.prototype.hammerPinchStart = function (event) {\n    this.zoom = this.model.cam.distTarget;\n  };\n\n  Controls.prototype.hammerPinch = function (event) {\n    this.model.cam.distTarget = this.zoom / event.scale;\n  };\n\n  Controls.prototype.hammerInput = function (event) {\n    if (this.modeVR === false) {\n      this.model.props.onJoystickMove(this.joystick.gestureInput(event));\n    }\n  };\n\n  Controls.prototype.raycast = function (event) {\n    this.mouseTap.x = event.pointers[0].clientX / this.model.vpW * 2 - 1;\n    this.mouseTap.y = event.pointers[0].clientY / this.model.vpH * -2 + 1;\n    \n    var pos = this.ray.rayCast(this.mouseTap);\n\n    if (typeof pos !== 'boolean') {\n      this.model.grid.moveRippleOrigin(pos.x, pos.z);\n    }\n  };\n\n  Controls.prototype.initKeyboard = function () {\n    window.addEventListener('keydown', this.model.props.onKeyDown.bind(this.model.props), false);\n    window.addEventListener('keyup', this.model.props.onKeyUp.bind(this.model.props), false);\n  };\n\n  Controls.prototype.initButtons = function () {\n    this.btnVR = document.getElementById('btnVR');\n    this.btnVRO = document.getElementById('btnVRO');\n    this.btnVREsc = document.getElementById('btnVREsc');\n    this.btnEnterF = document.getElementById('btnEnterFull');\n    this.btnExitF = document.getElementById('btnExitFull');\n\n    if (this.deviceAccel) {\n      this.modeOrbit = true;\n\n      this.btnVR.style.display = 'block';\n      this.btnVRO.style.display = 'block';\n\n      this.btnVR.addEventListener('click', this.enterVRMode.bind(this));\n      this.btnVRO.addEventListener('click', this.enterVROrbitMode.bind(this));\n     \n      this.btnVREsc.addEventListener('click', this.exitVRMode.bind(this));\n      this.noSleep = new NoSleep();\n    }\n\n    if (!/(iPad|iPhone|iPod)/g.test(navigator.userAgent)) {\n      this.btnEnterF.style.display = 'block';\n\n      this.btnExitF.addEventListener('click', this.fullScreenExit.bind(this));\n      this.btnEnterF.addEventListener('click', this.fullScreenEnter.bind(this));\n      \n      document.addEventListener('fullscreenchange', this.fullScreenChanged.bind(this), false);\n      document.addEventListener('MSFullscreenChange', this.fullScreenChanged.bind(this), false);\n      document.addEventListener('mozfullscreenchange', this.fullScreenChanged.bind(this), false);\n      document.addEventListener('webkitfullscreenchange', this.fullScreenChanged.bind(this), false);\n    }\n  };\n\n  Controls.prototype.enterVRMode = function () {\n    if (this.modeVR == true) {\n      return;\n    }\n\n    this.modeVR = true;\n    this.modeOrbit = false;\n\n    this.hideHUD();\n    this.changedVRMode();\n\n    this.noSleep.enable();\n  };\n\n  Controls.prototype.enterVROrbitMode = function () {\n    if (this.modeVR == true) {\n      return;\n    }\n\n    this.modeVR = true;\n    this.modeOrbit = true;\n\n    this.hideHUD();\n    this.changedVRMode();\n\n    this.noSleep.enable();\n  };\n\n  Controls.prototype.exitVRMode = function () {\n    if (this.modeVR == false) {\n      return;\n    }\n\n    this.modeVR = false;\n    this.modeOrbit = true;\n    this.model.props.joyVec.set(0, 0);\n\n    this.changedVRMode();\n    this.showHUD();\n\n    this.noSleep.disable();\n  };\n\n  Controls.prototype.changedVRMode = function () {\n    this.btnVR.style.display = this.modeVR ? 'none' : 'block';\n    this.btnVRO.style.display = this.modeVR ? 'none' : 'block';\n    this.btnVREsc.style.display = this.modeVR ? 'block' : 'none';\n\n    this.model.toggleStereo(this.modeVR, this.modeOrbit);\n  };\n\n  Controls.prototype.fullScreenChanged = function () {\n    if (document.fullscreen || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement == false) {\n      this.btnExitF.style.display = 'block';\n      this.btnEnterF.style.display = 'none';\n    } else {\n      this.btnExitF.style.display = 'none';\n      this.btnEnterF.style.display = 'block';\n    }\n  };\n\n  Controls.prototype.fullScreenEnter = function () {\n    if(this.pageMain.webkitRequestFullscreen) \n      this.pageMain.webkitRequestFullscreen();\n    else if (this.pageMain.mozRequestFullScreen) \n      this.pageMain.mozRequestFullScreen();\n    else \n      this.pageMain.requestFullscreen();\n    \n  };\n\n  Controls.prototype.fullScreenExit = function () {\n    if (document.webkitExitFullscreen)\n      document.webkitExitFullscreen();\n    else if (document.mozCancelFullScreen)\n      document.mozCancelFullScreen();\n    else\n      document.exitFullscreen();\n  };\n\n  Controls.prototype.acceleromTest = function (event) {\n    if (typeof event.alpha != 'undefined' && typeof event.beta != 'undefined' && typeof event.gamma != 'undefined') {\n      this.deviceAccel = true;\n    }\n\n    window.removeEventListener('deviceorientation', this.accelTestReference);\n  };\n\n  Controls.prototype.accelerometerMove = function (event) {\n    if (this.modeOrbit === true) {\n      this.model.cam.onGyroMove(event.alpha, event.beta, event.gamma);\n    } else {\n      this.gimbal.onGyroMove(event.alpha, event.beta, event.gamma);\n      \n      if (Math.abs(this.gimbal.roll) > 5) {\n        this.model.props.joyVec.x = THREE.Math.clamp(-this.gimbal.roll / 25, -1, 1);\n      } else {\n        this.model.props.joyVec.x = 0;\n      }\n\n      this.model.props.joyVec.y = THREE.Math.clamp((this.gimbal.attack + 20) / 30, -1, 1);\n    }\n  };\n\n  Controls.prototype.gestureWheel = function (event) {\n    switch (event.deltaMode) {\n      case 0:\n        this.model.cam.dolly(event.deltaY * 0.2);\n        break;\n        \n      case 1:\n        this.model.cam.dolly(event.deltaY * 20);\n        break;\n\n      case 2:\n        this.model.cam.dolly(event.deltaY * 40);\n        break;\n    }\n  };\n\n  Controls.prototype.onDeviceReorientation = function () {\n    this.model.deviceAngle = 0;\n\n    if (window.orientation) {\n      this.model.deviceAngle = parseInt(window.orientation.toString(), 10) * -1;\n    }\n\n    this.model.cam.onDeviceReorientation(this.model.deviceAngle);\n    this.gimbal.onDeviceReorientation(this.model.deviceAngle);\n  };\n\n  Controls.prototype.onWindowResize = function () {\n    this.model.onWindowResize();\n  };\n\n  Controls.prototype.update = function (t) {\n    if (this.introComplete === false)\n      this.model.updateIntro(t);\n    else\n      this.model.update(t, this.modeVR);\n    \n  };\n\n  return Controls;\n}();\n\nexports.default = Controls;\n\n//# sourceURL=webpack:///./src/Controls/Controls.ts?");

/***/ }),

/***/ "./src/Controls/Gimball.ts":
/*!*********************************!*\
  !*** ./src/Controls/Gimball.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Gimbal = function () {\n  function Gimbal() {\n    this.RAD = Math.PI / 180;\n    this.DEG = 180 / Math.PI;\n\n    this.quaternion = new THREE.Quaternion();\n\n    this.xVec = new THREE.Vector3(1, 0, 0);\n    this.yVec = new THREE.Vector3(0, 1, 0);\n    this.zVec = new THREE.Vector3(0, 0, 1);\n\n    this.deviceAngle = 0;\n\n    this.object = new THREE.Object3D();\n    this.angles = new THREE.Euler();\n    this.eulerOrigin = new THREE.Euler();\n\n    if (typeof window.orientation !== 'undefined') {\n      this.eulerOrigin.set(90 * this.RAD, 180 * this.RAD, (180 + parseInt(window.orientation.toString(), 10)) * this.RAD);\n    }\n  }\n\n  Gimbal.prototype.onGyroMove = function (_a, _b, _g) {\n    this.object.setRotationFromEuler(this.eulerOrigin);\n\n    this.object.rotateZ(_a * this.RAD);\n    this.object.rotateX(_b * this.RAD);\n    this.object.rotateY(_g * this.RAD);\n\n    this.object.rotation.z += this.deviceAngle;\n    this.quaternion.copy(this.object.quaternion.inverse());\n\n    this.yVec.set(0, 1, 0);\n    this.yVec.applyQuaternion(this.quaternion);\n    this.zVec.set(0, 0, 1);\n    this.zVec.applyQuaternion(this.quaternion);\n\n    this.heading = Math.atan2(this.zVec.x, this.zVec.z) * this.DEG;\n    \n    this.attack = Math.atan2(-this.yVec.z, this.yVec.y) * this.DEG;\n    this.attack = Math.min(Math.max(this.attack, -90), 90);\n    \n    this.roll = Math.atan2(-this.yVec.x, this.yVec.y) * this.DEG;\n  };\n\n  Gimbal.prototype.onDeviceReorientation = function (_orientation) {\n    this.deviceAngle = _orientation * this.RAD;\n  };\n\n  return Gimbal;\n}();\n\nexports.default = Gimbal;\n\n//# sourceURL=webpack:///./src/Controls/Gimball.ts?");

/***/ }),

/***/ "./src/Controls/Joystick.ts":
/*!**********************************!*\
  !*** ./src/Controls/Joystick.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Joystick = function () {\n  function Joystick() {\n    this.visible = false;\n    this.posStart = new THREE.Vector2();\n    this.posNow = new THREE.Vector2();\n\n    this.circleIn = document.getElementById('joyIn');\n    this.circleOut = document.getElementById('joyOut');\n  }\n\n  Joystick.prototype.gestureInput = function (event) {\n    if (event.pointers.length === 1) {\n      switch (event.eventType) {\n        case 1:\n          this.touchStart(event.pointers[0].clientX, event.pointers[0].clientY);\n          break;\n\n        case 2:\n          this.touchMove(event.pointers[0].clientX, event.pointers[0].clientY);\n          break;\n\n        case 4:\n          this.touchEnd();\n          break;\n      }\n    } else {\n      this.touchEnd();\n    }\n\n    return this.posNow;\n  };\n\n  Joystick.prototype.touchStart = function (_pX, _pY) {\n    this.visible = true;\n\n    this.circleIn.style.display = 'block';\n    this.circleIn.style.top = _pY + 'px';\n    this.circleIn.style.left = _pX + 'px';\n    \n    this.circleOut.style.display = 'block';\n    this.circleOut.style.top = _pY + 'px';\n    this.circleOut.style.left = _pX + 'px';\n\n    this.posStart.set(_pX, _pY);\n  };\n\n  Joystick.prototype.touchMove = function (_pX, _pY) {\n    if (this.visible === false) {\n      this.touchStart(_pX, _pY);\n    }\n\n    this.posNow.set(_pX - this.posStart.x, _pY - this.posStart.y);\n    this.posNow.clampLength(0, 40);\n    this.circleIn.style.transform = 'translate(' + (this.posNow.x - 34) + 'px, ' + (this.posNow.y - 34) + 'px)';\n  };\n\n  Joystick.prototype.touchEnd = function () {\n    this.circleIn.style.display = 'none';\n    this.circleOut.style.display = 'none';\n    this.circleIn.style.transform = 'translate(-34px, -34px)';\n    this.posNow.set(0, 0);\n    this.visible = false;\n  };\n\n  return Joystick;\n}();\n\nexports.default = Joystick;\n\n//# sourceURL=webpack:///./src/Controls/Joystick.ts?");

/***/ }),

/***/ "./src/Grid.ts":
/*!*********************!*\
  !*** ./src/Grid.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar rippleGen_1 = __webpack_require__(/*! ./Utility/RippleGenerator */ \"./src/Utility/RippleGenerator.ts\");\nvar utils_1 = __webpack_require__(/*! ./Utility/Utils */ \"./src/Utility/Utils.ts\");\nvar fragShader = __webpack_require__(/*! ./Shaders/FragmentShader */ \"./src/Shaders/FragmentShader.ts\");\nvar vertShader = __webpack_require__(/*! ./Shaders/VerticalShader */ \"./src/Shaders/VerticalShader.ts\");\n\nvar Grid = function () {\n  function Grid(_scene , _renderer ) {\n    this.GRID_SIZE = 32;\n    this.GRID_HALFSIZE = 16;\n    this.parent = _scene;\n    this.prevOrigin = new THREE.Vector2();\n    this.ripplePos = new THREE.Vector2();\n    this.rippleGen = new rippleGen_1.default(_renderer, this.ripplePos, this.GRID_SIZE);\n    this.generateGrid();\n  }\n\n  Grid.prototype.generateGrid = function () {\n    this.ledSprite = new THREE.TextureLoader().load('textures/ledA.png');\n    this.color = new THREE.Color(0xFFFFFF);\n\n    this.gridMaterial = new THREE.ShaderMaterial({\n      uniforms: {\n        led: {\n          value: this.ledSprite\n        },\n        heightmap: {\n          value: null\n        },\n        vpH: {\n          value: window.innerHeight\n        },\n        prog: {\n          value: 0\n        },\n        origin: {\n          value: new THREE.Vector2()\n        },\n        color: {\n          value: this.color\n        }\n      },\n      defines: {\n        RANGE: (this.GRID_SIZE / 2).toFixed(1),\n        RANGE2: this.GRID_SIZE.toFixed(1)\n      },\n      vertexShader: vertShader,\n      fragmentShader: fragShader,\n      transparent: true,\n      depthWrite: false\n    });\n\n    this.uniProgress = this.gridMaterial.uniforms['prog'];\n    this.uniOrigin = this.gridMaterial.uniforms['origin'];\n    var vertCount = Math.pow(this.GRID_SIZE, 2);\n    var position = new Float32Array(vertCount * 3);\n    var uvs = new Float32Array(vertCount * 2);\n    var diagonal = new Uint16Array(vertCount);\n    var randI = THREE.Math.randInt;\n    var xPos = 0;\n    var zPos = 0;\n\n    for (var i = 0, i3 = 0; i < vertCount; i++, i3 += 3) {\n      xPos = i % this.GRID_SIZE;\n      zPos = Math.floor(i / this.GRID_SIZE);\n      position[i3 + 0] = xPos - this.GRID_HALFSIZE;\n      position[i3 + 1] = 0;\n      position[i3 + 2] = zPos - this.GRID_HALFSIZE;\n      uvs[i * 2 + 0] = xPos / this.GRID_SIZE;\n      uvs[i * 2 + 1] = 1 - zPos / this.GRID_SIZE;\n      diagonal[i] = (xPos + zPos) % 2;\n    }\n\n    this.geometry = new THREE.BufferGeometry();\n    this.geometry.addAttribute('position', new THREE.BufferAttribute(position, 3));\n    this.geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n    this.geometry.addAttribute('diagonal', new THREE.BufferAttribute(diagonal, 1));\n    this.lightGrid = new THREE.Points(this.geometry, this.gridMaterial);\n    this.lightGrid.frustumCulled = false;\n    this.parent.add(this.lightGrid);\n  };\n\n  Grid.prototype.moveRippleOrigin = function (_x, _y) {\n    this.ripplePos.set(_x, _y);\n  };\n\n  Grid.prototype.showWhiteGrid = function () {\n    TweenLite.to(this.uniProgress, 2, {\n      value: 1,\n      easing: Power2.easeInOut,\n      onStart: function () {}.bind(this)\n    });\n  };\n\n  Grid.prototype.goToBlackGrid = function () {\n    TweenLite.to(this.color, 1, {\n      r: 0,\n      g: 0,\n      b: 0,\n      easing: Power2.easeInOut\n    });\n\n    TweenLite.to(this.uniProgress, 1, {\n      value: 0,\n      easing: Power2.easeInOut\n    });\n  };\n\n  Grid.prototype.update = function (_props) {\n    if (typeof _props != 'undefined' && _props.speed > 0) {\n      this.rippleGen.newRippleImpact(_props.speed / 64);\n      this.moveRippleOrigin(utils_1.mod(_props.pos.x + this.GRID_HALFSIZE, this.GRID_SIZE) - this.GRID_HALFSIZE, utils_1.mod(_props.pos.y + this.GRID_HALFSIZE, this.GRID_SIZE) - this.GRID_HALFSIZE);\n      this.uniOrigin.value = _props.pos;\n    }\n\n    this.gridMaterial.uniforms['heightmap'].value = this.rippleGen.update();\n    this.moveRippleOrigin(1000, 1000);\n  };\n\n  Grid.prototype.onWindowResize = function (vpW, vpH, pixelRatio) {\n    this.gridMaterial.uniforms['vpH'].value = vpH * pixelRatio;\n  };\n\n  return Grid;\n}();\n\nexports.default = Grid;\n\n//# sourceURL=webpack:///./src/Grid.ts?");

/***/ }),

/***/ "./src/Init.ts":
/*!*********************!*\
  !*** ./src/Init.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Controls_1 = __webpack_require__(/*! ./Controls/Controls */ \"./src/Controls/Controls.ts\");\nvar control;\n\nfunction noWebGL() {\n  document.getElementById('preloader').className = 'visible';\n  document.getElementById('preLogo').style.display = 'block';\n  document.getElementById('preButton').style.display = 'block';\n  document.getElementById('preDetail').innerHTML = translations['BROWSER_BAD'];\n}\n\nfunction initApp() {\n  control = new Controls_1.default();\n  render(0);\n}\n\nfunction render(t) {\n  control.update(t * 0.001);\n  requestAnimationFrame(render);\n}\n\nfunction browserCheck() {\n  return !navigator.userAgent.match(/UCBrowser/);\n}\n\nfunction detectWebGL() {\n  try {\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    window['EXT_STLOD_SUPPORT'] = context.getExtension('EXT_shader_texture_lod') ? true : false;\n    return !!(window.WebGLRenderingContext && context);\n  } catch (e) {\n    return false;\n  }\n}\nif (detectWebGL() && browserCheck()) {\n  initApp();\n} else {\n  noWebGL();\n}\n\n//# sourceURL=webpack:///./src/Init.ts?");

/***/ }),

/***/ "./src/Model.ts":
/*!**********************!*\
  !*** ./src/Model.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar camera_1 = __webpack_require__(/*! ./Controls/CameraControl */ \"./src/Controls/CameraControl.ts\");\nvar binocs_1 = __webpack_require__(/*! ./Utility/Binocs */ \"./src/Utility/Binocs.ts\");\nvar CarBody_1 = __webpack_require__(/*! ./Car/CarBody */ \"./src/Car/CarBody.ts\");\nvar CarProps_1 = __webpack_require__(/*! ./Car/CarProps */ \"./src/Car/CarProps.ts\");\nvar grid_1 = __webpack_require__(/*! ./Grid */ \"./src/Grid.ts\");\nvar Utils = __webpack_require__(/*! ./Utility/Utils */ \"./src/Utility/Utils.ts\");\n\nvar Model = function () {\n  function Model(_main) {\n    this.deviceAngle = 0;\n    this.pageMain = _main;\n    this.vpW = this.pageMain.clientWidth;\n    this.vpH = this.pageMain.clientHeight;\n    this.props = new CarProps_1.CarProps();\n    this.camTarget = new THREE.Vector3(0, 1, 1.56);\n    this.scene = new THREE.Scene();\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    \n    this.renderer.setPixelRatio(1);\n    this.renderer.setSize(this.vpW, this.vpH);\n    this.renderer.setClearColor(0x393533);\n    this.renderer.autoClear = false;\n    this.camOptions = {\n      distance: 7,\n      focusPos: this.camTarget,\n      distRange: {\n        max: 40,\n        min: 4\n      },\n      rotation: new THREE.Vector3(45, 0, 0),\n      rotRange: {\n        yMin: -1\n      },\n      eyeSeparation: 0.3\n    };\n\n    this.monoc = new camera_1.default(this.camOptions);\n    this.cam = this.monoc;\n    this.grid = new grid_1.default(this.scene, this.renderer);\n    this.pageMain.appendChild(this.renderer.domElement);\n    this.addSceneLights();\n  }\n\n  Model.prototype.introPreloading = function () {\n    this.grid.showWhiteGrid();\n\n    TweenLite.to(this.cam, 1, {\n      distTarget: 30\n    });\n\n    TweenLite.to(this.cam.rotTarget, 1, {\n      x: 0,\n      y: 90\n    });\n  };\n  \n  Model.prototype.introPreloaded = function (_cargo) {\n    this.car = new CarBody_1.default(this.scene, _cargo);\n    this.skyRadiance = _cargo['envSkybox'];\n    this.skyRadiance.format = THREE.RGBFormat;\n    this.scene.background = this.skyRadiance;\n  };\n\n  Model.prototype.introStart = function () {\n    this.grid.goToBlackGrid();\n\n    TweenLite.to(this.cam.rotTarget, 1, {\n      x: -20,\n      y: 0\n    });\n\n    TweenLite.to(this.cam, 1, {\n      distTarget: 10,\n      distActual: 10\n    });\n\n    TweenLite.to(this.spotLight, 3, {\n      intensity: 1\n    });\n\n    TweenLite.to(this.props, 3, {\n      speed: 12\n    });\n  };\n\n  Model.prototype.addSceneLights = function () {\n    this.ambLight = new THREE.AmbientLight(0xFFFFFF, 0.2);\n    this.spotLight = new THREE.DirectionalLight(0xFFFFFF, 0);\n    \n    this.spotLight.position.set(0, 2, 0);\n\n    this.scene.add(this.spotLight);\n    this.scene.add(this.ambLight);\n  };\n  \n  Model.prototype.toggleStereo = function (_stereo, _orbit) {\n    if (_stereo) {\n      if (typeof this.binocs === 'undefined') {\n        this.binocs = new binocs_1.default(this.camOptions);\n        this.binocs.distTarget = 10;\n      }\n\n      this.cam = this.binocs;\n      this.scene.add(this.binocs.binoculars);\n      \n      this.renderer.setScissorTest(true);\n      this.renderer.setPixelRatio(window.devicePixelRatio >= 2 ? 2 : 1);\n      \n      if (_orbit === false) {\n        this.binocs.setRotation(Utils.mod(this.monoc.rotActual.x, 360), this.monoc.rotActual.y, 0);\n        this.binocs.rotTarget.x = 180 - Math.atan2(this.props.velocity.x, this.props.velocity.y) * (180 / Math.PI);\n        this.binocs.rotTarget.y = 10;\n      }\n    } else {\n      this.cam = this.monoc;\n      this.scene.remove(this.binocs.binoculars);\n\n      this.renderer.setViewport(0, 0, this.vpW, this.vpH);\n      this.renderer.setScissorTest(false);\n      this.renderer.setPixelRatio(1);\n    }\n    \n    this.grid.onWindowResize(this.vpW, this.vpH, this.renderer.getPixelRatio());\n    this.cam.onDeviceReorientation(this.deviceAngle);\n\n    this.onWindowResize();\n  };\n\n  Model.prototype.onWindowResize = function () {\n    this.vpW = this.pageMain.clientWidth;\n    this.vpH = this.pageMain.clientHeight;\n\n    this.grid.onWindowResize(this.vpW, this.vpH, this.renderer.getPixelRatio());\n    this.car.onWindowResize(this.vpH);\n    this.renderer.setSize(this.vpW, this.vpH);\n    this.monoc.onWindowResize(this.vpW, this.vpH);\n\n    if (typeof this.binocs !== 'undefined') {\n      this.binocs.onWindowResize(this.vpW, this.vpH);\n    }\n  };\n\n  Model.prototype.updateIntro = function (time) {\n    this.renderer.clear();\n    this.grid.update();\n    this.cam.update();\n    this.renderer.render(this.scene, this.monoc.camera);\n  };\n\n  Model.prototype.update = function (time, _stereo) {\n    if (this.props.update(time) === false) {\n      return;\n    }\n\n    this.renderer.clear();\n\n    this.car.update(this.props);\n    this.grid.update(this.props);\n    \n    this.camTarget.copy(this.car.carChassis.getWorldPosition());\n    \n    this.cam.setFocusPos(this.camTarget.x, 1, this.camTarget.z);\n    this.cam.update();\n\n    if (_stereo) {\n      this.spotLight.position.copy(this.binocs.binoculars.position).normalize();\n      this.spotLight.position.y = 1;\n      this.binocs.renderStereo(this.renderer, this.scene);\n    } else {\n      this.spotLight.position.copy(this.monoc.camera.position).normalize();\n      this.spotLight.position.y = 1;\n      this.renderer.render(this.scene, this.monoc.camera, null, false);\n    }\n  };\n\n  return Model;\n}();\n\nexports.default = Model;\n\n//# sourceURL=webpack:///./src/Model.ts?");

/***/ }),

/***/ "./src/Preloader.ts":
/*!**************************!*\
  !*** ./src/Preloader.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Preloader = function () {\n  function Preloader(_path, _manifesto, _parent) {\n    this.path = _path;\n    this.manifesto = _manifesto;\n    this.parent = _parent;\n    this.assetCount = 0;\n    this.assetTotal = _manifesto.length;\n    this.loaderText = new THREE.TextureLoader();\n    this.loaderMesh = new THREE.ObjectLoader();\n    this.loaderCube = new THREE.CubeTextureLoader();\n    this.cargo = {};\n    this.container = document.getElementById('preloader');\n    this.progBar = document.getElementById('preProg');\n    this.detailBox = document.getElementById('preDetail');\n  }\n  Preloader.prototype.start = function () {\n    this.container.className = 'visible';\n    this.detailBox.innerHTML = translations['LOADING_ASSETS'];\n    var ext;\n    var _loop_1 = function (i) {\n      ext = '.' + this_1.manifesto[i].ext;\n      switch (this_1.manifesto[i].type) {\n        case 'texture':\n          this_1.loaderText.load(this_1.path + 'textures/' + this_1.manifesto[i].name + ext, function (_obj) {\n            this.assetAquired(_obj, this.manifesto[i].name);\n          }.bind(this_1), undefined, function (_err) {\n            this.assetFailed(_err, this.manifesto[i].name);\n          }.bind(this_1));\n          break;\n        case 'mesh':\n          this_1.loaderMesh.load(this_1.path + 'meshes/' + this_1.manifesto[i].name + '.json', function (_obj) {\n            this.assetAquired(_obj, this.manifesto[i].name);\n          }.bind(this_1), undefined, function (_err) {\n            this.assetFailed(_err, this.manifesto[i].name);\n          }.bind(this_1));\n          break;\n        case 'cubetexture':\n          this_1.loaderCube.setPath(this_1.path + 'textures/' + this_1.manifesto[i].name + '/');\n          this_1.loaderCube.load([\n            'xp' + ext,\n            'xn' + ext,\n            'yp' + ext,\n            'yn' + ext,\n            'zp' + ext,\n            'zn' + ext\n          ], function (_obj) {\n            this.assetAquired(_obj, this.manifesto[i].name);\n          }.bind(this_1), undefined, function (_err) {\n            this.assetFailed(_err, this.manifesto[i].name);\n          }.bind(this_1));\n          break;\n      }\n    };\n    var this_1 = this;\n    for (var i = 0; i < this.assetTotal; i++) {\n      _loop_1(i);\n    }\n  };\n  Preloader.prototype.assetAquired = function (_obj, _name) {\n    this.cargo[_name] = _obj;\n    this.assetCount++;\n    this.pct = this.assetCount / this.assetTotal;\n    this.progBar.style.width = this.pct * 100 + '%';\n    if (this.assetCount == this.assetTotal) {\n      this.complete();\n    }\n  };\n  Preloader.prototype.assetFailed = function (_err, _name) {\n    this.assetCount++;\n    this.pct = this.assetCount / this.assetTotal;\n    if (this.assetCount == this.assetTotal) {\n      this.complete();\n    }\n  };\n  Preloader.prototype.complete = function () {\n    this.detailBox.innerHTML = translations['BUILDING_CAR'];\n    TweenLite.delayedCall(0.5, function () {\n      this.parent.preloadComplete(this.cargo);\n      this.detailBox.innerHTML = translations['TAP_TO_BEGIN'];\n    }.bind(this));\n  };\n  Preloader.prototype.remove = function () {\n    this.container.className = '';\n  };\n  return Preloader;\n}();\nexports.Preloader = Preloader;\n\n//# sourceURL=webpack:///./src/Preloader.ts?");

/***/ }),

/***/ "./src/Shaders/FlareFS.ts":
/*!********************************!*\
  !*** ./src/Shaders/FlareFS.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform vec3 color;\\nuniform sampler2D texture;\\n\\nvarying float opacity;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\t// Additive\\n    gl_FragColor = texture2D( texture, gl_PointCoord);\\n    gl_FragColor.a = normFloat(opacity, 0.01, 0.1);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/FlareFS.ts?");

/***/ }),

/***/ "./src/Shaders/FlareVS.ts":
/*!********************************!*\
  !*** ./src/Shaders/FlareVS.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define PI 3.1415926\\n\\nuniform float vpH;\\nuniform float size;\\nuniform float brightness;\\nvarying float opacity;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n    vec4 realPos = modelMatrix * vec4(position, 1.0);\\n    vec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n    vec3 lightVector = normalize(cameraPosition - realPos.xyz);\\n    opacity = dot(realNorm, lightVector);\\n    opacity = normFloat(opacity, 0.5, 1.0) * brightness;\\n\\n    vec4 mvPosition = viewMatrix * realPos;\\n    gl_Position = projectionMatrix * mvPosition;\\n    gl_PointSize = max((vpH * size / -mvPosition.z) * opacity, 0.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/FlareVS.ts?");

/***/ }),

/***/ "./src/Shaders/FragmentShader.ts":
/*!***************************************!*\
  !*** ./src/Shaders/FragmentShader.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform sampler2D led;\\nuniform vec3 color;\\n\\nvarying float opacity;\\nvarying float diag;\\n\\nvoid main() {\\n\\t// Multiplicative\\n    // gl_FragColor = -texture2D( led, vec2(abs(diag - gl_PointCoord.x), gl_PointCoord.y )) * opacity;\\n    // gl_FragColor += 1.0;\\n\\n\\t// Additive\\n    gl_FragColor = texture2D( led, vec2(abs(diag - gl_PointCoord.x), gl_PointCoord.y )) * vec4(color, opacity);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/FragmentShader.ts?");

/***/ }),

/***/ "./src/Shaders/HMFragment.ts":
/*!***********************************!*\
  !*** ./src/Shaders/HMFragment.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'precision highp float;\\nprecision highp int;\\n\\n#include <common>\\n\\nuniform vec2 ripplePos;\\nuniform float rippleSize;\\nuniform float viscosity;\\nuniform float rippleImpact;\\nuniform sampler2D heightmap;\\n\\n#define deltaTime ( 1.0 / 60.0 )\\n#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 1.0 )\\n\\nvoid main()\\t{\\n\\n\\tvec2 cellSize = 1.0 / resolution.xy;\\n\\n\\tvec2 uv = gl_FragCoord.xy * cellSize;\\n\\n\\t// heightmapValue.x == height\\n\\t// heightmapValue.y == velocity\\n\\t// heightmapValue.z, heightmapValue.w not used\\n\\tvec4 heightmapValue = texture2D( heightmap, uv );\\n\\n\\t// Get neighbours\\n\\tfloat north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) ).r;\\n\\tfloat south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) ).r;\\n\\tfloat east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) ).r;\\n\\tfloat west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) ).r;\\n\\n\\tfloat sump = north + south + east + west - 4.0 * heightmapValue.x;\\n\\n\\tfloat accel = sump * GRAVITY_CONSTANT;\\n\\n\\t// Dynamics\\n\\theightmapValue.y += accel;\\n\\theightmapValue.x += heightmapValue.y * deltaTime;\\n\\n\\t// Viscosity\\n\\theightmapValue.x += sump * viscosity;\\n\\n\\t// Mouse influence\\n\\tfloat mousePhase = clamp( \\n\\t\\tlength(( uv - vec2( 0.5 ) ) * BOUNDS - vec2( ripplePos.x, - ripplePos.y ) ) * PI / rippleSize, \\n\\t\\t0.0, \\n\\t\\tPI\\n\\t);\\n\\theightmapValue.x += (cos( mousePhase ) + 1.0) * rippleImpact;\\n\\n\\t// Bring X back to 0 over time to prevent endless growth\\n\\theightmapValue.x *= 0.998;\\n\\n\\t// gl_FragColor = vec4(heightmapValue.x, 0.0, 0.0, 1.0);\\n\\tgl_FragColor = heightmapValue;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/HMFragment.ts?");

/***/ }),

/***/ "./src/Shaders/HeadGridVS.ts":
/*!***********************************!*\
  !*** ./src/Shaders/HeadGridVS.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'float normFloat(float n, float minVal, float maxVal){\\n\\treturn max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\n// Returns 1 if type matches val, 0 if not\\nfloat checkType(float type, float val){\\n\\treturn step(val - 0.1, type) * step(type, val + 0.1);\\n}\\n\\nuniform vec3 lightsT;\\nuniform vec3 lightsO;\\nattribute float type;\\nvarying float wht;\\nvarying float amb;\\n\\n// z-up position because Blender is weird like that\\nvoid main() {\\n\\tvec2 posXY = vec2(position.y - 2299.0, position.z - 1355.0);\\n\\tfloat distOrigin = distance(posXY, vec2(0.0));   // FF Logo\\n\\n\\t// 0: Daytime running lights\\n\\twht = checkType(type, 0.0);\\n\\t\\n\\t// 1: nightlights\\n\\twht += checkType(type, 1.0) * lightsO.y;\\n\\t\\n\\t// 2: high beams\\n\\twht += checkType(type, 2.0) * lightsO.z;\\n\\t\\n\\t// 3: right turn signal\\n\\twht += checkType(type, 3.0) * (1.0 - lightsT.x);\\n\\tamb = checkType(type, 3.0) * lightsT.z;\\n\\t\\n\\t// 4: left turn signal\\n\\twht += checkType(type, 4.0) * (1.0 + lightsT.x);\\n\\tamb += checkType(type, 4.0) * lightsT.y;\\n\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/HeadGridVS.ts?");

/***/ }),

/***/ "./src/Shaders/RawVertical.ts":
/*!************************************!*\
  !*** ./src/Shaders/RawVertical.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'precision highp float;\\nprecision highp int;\\n\\nattribute vec3 position;\\nattribute vec2 uv;\\nvarying vec2 vUv;\\n\\nvoid main() {\\n\\tvUv = uv;\\n\\tgl_Position = vec4(position, 1.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/RawVertical.ts?");

/***/ }),

/***/ "./src/Shaders/ReverseGridFS.ts":
/*!**************************************!*\
  !*** ./src/Shaders/ReverseGridFS.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform sampler2D texture;\\nvarying float brightness;\\nvarying vec2 gUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\t// Additive\\n    gl_FragColor = texture2D( texture, gUV) * brightness;\\n\\n\\t// Subtractive\\n\\t// gl_FragColor = texture2D( texture, gl_PointCoord ) - vec4( color, 1.0 );\\n\\t// gl_FragColor *= opacity;\\n\\n\\t// Multip\\n\\t/* gl_FragColor = -texture2D( texture, gl_PointCoord ) * opacity;\\n\\tgl_FragColor *= 1.0 - vec4( color, 1.0 );\\n\\tgl_FragColor += 1.0; */\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/ReverseGridFS.ts?");

/***/ }),

/***/ "./src/Shaders/VerticalShader.ts":
/*!***************************************!*\
  !*** ./src/Shaders/VerticalShader.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define PI 3.1415926\\n\\nattribute float diagonal;\\n\\nuniform sampler2D heightmap;\\nuniform float vpH;\\nuniform vec2 origin;\\nuniform float prog;\\n\\nvarying float opacity;\\nvarying float diag;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n\\treturn max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\tdiag = diagonal;\\n\\tfloat fluctuation = -texture2D(heightmap, uv).r;\\n\\n\\t// Endless threadmill\\n\\tvec3 newPos = position;\\n\\tnewPos.xz -= origin;\\n\\tnewPos.x = (fract((newPos.x + RANGE) / RANGE2) * RANGE2) - RANGE;\\n\\tnewPos.z = (fract((newPos.z + RANGE) / RANGE2) * RANGE2) - RANGE;\\n\\tnewPos.y = fluctuation * 0.5;\\n\\n\\t// Size\\n\\tfloat size = normFloat(abs(cameraPosition.y), -0.5, 2.0) * 0.25;\\n\\n\\t// Fade out as camera fog\\n\\tfloat distOrigin = distance(newPos.xz, vec2(-0.5, 0.0));\\n\\topacity = (fluctuation + 0.5) * normFloat(distOrigin, RANGE, RANGE * 0.5);\\n\\n\\t// Make logo\\n\\tfloat ffLogo = step(distOrigin, 1.7) * prog;\\n\\t//newPos.y = max(ffLogo * 0.5, newPos.y);\\n\\topacity = max(ffLogo, opacity);\\n\\tsize = max(ffLogo, size);\\n\\n\\t// Position, size    \\n\\tvec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\tgl_PointSize = vpH * size / -mvPosition.z;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/VerticalShader.ts?");

/***/ }),

/***/ "./src/Shaders/headgridFS.ts":
/*!***********************************!*\
  !*** ./src/Shaders/headgridFS.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define RED vec3(1.0, 0.1, 0.1) // red\\n#define AMB vec3(1.0, 0.6, 0.1)\\t// amber\\n#define WHT vec3(1.0, 1.0, 1.0)\\t// white\\n\\nvarying float wht;\\nvarying float amb;\\n\\nvoid main() {\\n\\tgl_FragColor = vec4((WHT * wht + AMB * amb), 1.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/headgridFS.ts?");

/***/ }),

/***/ "./src/Shaders/reverseBarVS.ts":
/*!*************************************!*\
  !*** ./src/Shaders/reverseBarVS.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'varying float brightness;\\nvarying vec2 gUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\tgUV = uv;\\n    vec4 realPos = modelMatrix * vec4(position, 1.0);\\n    vec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n    vec3 lightVector = normalize(cameraPosition - realPos.xyz);\\n    float diffuse = dot(realNorm, lightVector);\\n    brightness = normFloat(diffuse, 0.0, 0.5);\\n\\n    vec4 mvPosition = viewMatrix * realPos;\\n    gl_Position = projectionMatrix * mvPosition;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/reverseBarVS.ts?");

/***/ }),

/***/ "./src/Shaders/stopBarVS.ts":
/*!**********************************!*\
  !*** ./src/Shaders/stopBarVS.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'varying float brightness;\\nvarying vec2 vUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\tvUV = uv;\\n    vec4 realPos = modelMatrix * vec4(position, 1.0);\\n    vec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n    vec3 lightVector = normalize(cameraPosition - realPos.xyz);\\n    float diffuse = dot(realNorm, lightVector);\\n    brightness = normFloat(diffuse, 0.0, 0.5);\\n\\n    vec4 mvPosition = viewMatrix * realPos;\\n    gl_Position = projectionMatrix * mvPosition;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/stopBarVS.ts?");

/***/ }),

/***/ "./src/Shaders/tailGridFS.ts":
/*!***********************************!*\
  !*** ./src/Shaders/tailGridFS.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define RED vec3(1.0, 0.1, 0.1) // red\\n#define AMB vec3(1.0, 0.6, 0.1)\\t// amber\\n#define WHT vec3(1.0, 1.0, 1.0)\\t// white\\n\\nvarying float red;\\nvarying float amb;\\nvarying float wht;\\nvarying float brightness;\\n\\nvoid main() {\\n\\tgl_FragColor = vec4((RED * red + AMB * amb) * brightness, 1.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/tailGridFS.ts?");

/***/ }),

/***/ "./src/Shaders/tailGridVS.ts":
/*!***********************************!*\
  !*** ./src/Shaders/tailGridVS.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define NIGHTLIGHT 0.4\\n\\nfloat normFloat(float n, float minVal, float maxVal){\\n\\treturn max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\n// Returns 1 if type matches val, 0 if not\\nfloat checkType(float type, float val){\\n\\treturn step(val - 0.1, type) * step(type, val + 0.1);\\n}\\n\\nuniform vec3 lightsT;\\nuniform vec3 lightsO;\\nattribute float type;\\nvarying float red;\\nvarying float amb;\\nvarying float wht;\\nvarying float brightness;\\n\\nvoid main(){\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n \\tvec3 realPos = vec3(modelMatrix * vec4(position, 1.0));\\n\\tvec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n\\tvec3 lightVector = normalize(cameraPosition - realPos);\\n\\tbrightness = dot(realNorm, lightVector);\\n\\tbrightness = normFloat(brightness, 0.3, 0.2) + 0.5;\\n\\tbrightness *= brightness * brightness;\\n\\t\\n\\t// Type 0: FF logo\\t\\n\\tred = checkType(type, 0.0);\\n\\t// FF brightens on stop light\\n\\tred += red * lightsO.x;\\n\\n\\t// Type 1: center grid\\n\\tred += checkType(type, 1.0) * NIGHTLIGHT;\\n\\n\\t// Type 2: Right blinker\\n\\tred += (checkType(type, 2.0) * NIGHTLIGHT) * step(lightsT.x, 0.0);\\n\\tamb = checkType(type, 2.0) * lightsT.z;\\n\\n\\t// Type 3: Left blinker\\n\\tred += (checkType(type, 3.0) * NIGHTLIGHT) * step(0.0, lightsT.x);\\n\\tamb += checkType(type, 3.0) * lightsT.y;\\n\\t\\n\\tbrightness = clamp(brightness, 0.0, 1.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/tailGridVS.ts?");

/***/ }),

/***/ "./src/Shaders/tailLightVS.ts":
/*!************************************!*\
  !*** ./src/Shaders/tailLightVS.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define NIGHTLIGHT 0.4\\n\\nfloat normFloat(float n, float minVal, float maxVal){\\n\\treturn max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\n// Returns 1 if type matches val, 0 if not\\nfloat checkType(float type, float val){\\n\\treturn step(val - 0.1, type) * step(type, val + 0.1);\\n}\\n\\nuniform vec3 lightsT;\\nuniform vec3 lightsO;\\nattribute float type;\\nvarying float red;\\nvarying float amb;\\nvarying float wht;\\nvarying float brightness;\\n\\nvoid main(){\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\tbrightness = 1.0;\\n\\n\\t// Type 0: Reverse light?\\n\\tamb = checkType(type, 0.0) * lightsO.x;\\n\\t// Type 1: Right blinker\\n\\tamb += checkType(type, 1.0) * lightsT.z;\\n\\n\\t// Type 2: Left blinker\\n\\tamb += checkType(type, 2.0) * lightsT.y;\\n\\n\\t// Type 3: Side brakelights & side nightlights\\n\\tred = checkType(type, 3.0) * (NIGHTLIGHT + lightsO.x * (1.0 - NIGHTLIGHT));\\n\\n\\t// Type 4: Center brakelight\\n\\tred += checkType(type, 4.0) * lightsO.x;\\n\\n\\t// Type 5: Center nightlight\\n\\tred += checkType(type, 5.0) * NIGHTLIGHT;\\n\\n\\t// Type 6: Lower foglights off\\n\\tred += checkType(type, 6.0) * NIGHTLIGHT * 0.2;\\n\\n\\t// Type 7: Lower foglights on\\n\\tred += checkType(type, 7.0) * NIGHTLIGHT * 1.5;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/tailLightVS.ts?");

/***/ }),

/***/ "./src/Shaders/turnBarFS.ts":
/*!**********************************!*\
  !*** ./src/Shaders/turnBarFS.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform sampler2D texture;\\nvarying float brightness;\\nvarying vec2 vUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\t// Additive\\n    gl_FragColor = texture2D( texture, vUV) * brightness;\\n\\n\\t// Subtractive\\n\\t// gl_FragColor = texture2D( texture, gl_PointCoord ) - vec4( color, 1.0 );\\n\\t// gl_FragColor *= opacity;\\n\\n\\t// Multip\\n\\t/* gl_FragColor = -texture2D( texture, gl_PointCoord ) * opacity;\\n\\tgl_FragColor *= 1.0 - vec4( color, 1.0 );\\n\\tgl_FragColor += 1.0; */\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/turnBarFS.ts?");

/***/ }),

/***/ "./src/Shaders/turnBarVS.ts":
/*!**********************************!*\
  !*** ./src/Shaders/turnBarVS.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform vec3 lightsT;\\nvarying float brightness;\\nvarying vec2 vUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\tvUV = uv;\\n    vec4 realPos = modelMatrix * vec4(position, 1.0);\\n    vec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n    vec3 lightVector = normalize(cameraPosition - realPos.xyz);\\n    float diffuse = dot(realNorm, lightVector);\\n    brightness = step(2000.0, position.y) * lightsT.z + step(position.y, 2000.0) * lightsT.y;\\n    brightness *= normFloat(diffuse, 0.0, 0.5);\\n\\n    vec4 mvPosition = viewMatrix * realPos;\\n    gl_Position = projectionMatrix * mvPosition;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/turnBarVS.ts?");

/***/ }),

/***/ "./src/Utility/Binocs.ts":
/*!*******************************!*\
  !*** ./src/Utility/Binocs.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Binocs = function () {\n  function Binocs(options) {\n    this.options = {\n      distance: 90,\n      focusPos: new THREE.Vector3(),\n      rotation: new THREE.Vector3(),\n      distRange: {\n        max: Number.POSITIVE_INFINITY,\n        min: Number.NEGATIVE_INFINITY\n      },\n      fov: 45,\n      eyeSeparation: 1.5\n    };\n    for (var key in options) {\n      if (key === 'distRange') {\n        for (var key in options.distRange) {\n          this.options.distRange[key] = options.distRange[key];\n        }\n      } else {\n        this.options[key] = options[key];\n      }\n    }\n    this.distActual = this.options.distance;\n    this.distTarget = this.options.distance;\n    this.focusActual = this.options.focusPos.clone();\n    this.focusTarget = this.options.focusPos.clone();\n    this.rotActual = this.options.rotation.clone();\n    this.rotTarget = this.options.rotation.clone();\n    this.vpW = window.innerWidth;\n    this.vpH = window.innerHeight;\n    this.binoculars = new THREE.Object3D();\n    this.lensL = new THREE.PerspectiveCamera(this.options.fov, this.vpW / 2 / this.vpH, 0.1, 100);\n    this.lensR = new THREE.PerspectiveCamera(this.options.fov, this.vpW / 2 / this.vpH, 0.1, 100);\n    this.lensL.position.setX(-this.options.eyeSeparation / 2);\n    this.lensR.position.setX(this.options.eyeSeparation / 2);\n    this.binoculars.add(this.lensL);\n    this.binoculars.add(this.lensR);\n    this.radians = Math.PI / 180;\n    this.quatX = new THREE.Quaternion();\n    this.quatY = new THREE.Quaternion();\n    this.gyro = { orient: 0 };\n    if (typeof window.orientation !== 'undefined') {\n      this.defaultEuler = new THREE.Euler(90 * this.radians, 180 * this.radians, (180 + parseInt(window.orientation.toString(), 10)) * this.radians);\n    } else {\n      this.defaultEuler = new THREE.Euler(0, 0, 0);\n    }\n    this.addVignette();\n  }\n  Binocs.prototype.addVignette = function () {\n    var outer = 0.05;\n    var edge = outer * 0.8;\n    var corner = outer * 0.75;\n    var shape = new THREE.Shape();\n    shape.moveTo(-outer, -outer);\n    shape.lineTo(outer, -outer);\n    shape.lineTo(outer, outer);\n    shape.lineTo(-outer, outer);\n    shape.closePath();\n    var hole = new THREE.Path();\n    hole.moveTo(-corner, -corner);\n    hole.bezierCurveTo(-edge, 0, -edge, 0, -corner, corner);\n    hole.bezierCurveTo(0, edge, 0, edge, corner, corner);\n    hole.bezierCurveTo(edge, 0, edge, 0, corner, -corner);\n    hole.bezierCurveTo(0, -edge, 0, -edge, -corner, -corner);\n    shape.holes.push(hole);\n    this.vigGeom = new THREE.ShapeGeometry(shape, 6);\n    this.vigMat = new THREE.MeshBasicMaterial({\n      color: 0x000000,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.vignetteL = new THREE.Mesh(this.vigGeom, this.vigMat);\n    this.vignetteR = this.vignetteL.clone();\n    this.vignetteL.position.set(-this.options.eyeSeparation / 2, 0, -0.11);\n    this.vignetteR.position.set(this.options.eyeSeparation / 2, 0, -0.11);\n    this.vignetteL.scale.set(this.vpW / 2 / this.vpH, 1, 1);\n    this.vignetteR.scale.set(this.vpW / 2 / this.vpH, 1, 1);\n    this.binoculars.add(this.vignetteL);\n    this.binoculars.add(this.vignetteR);\n  };\n  Binocs.prototype.setDistance = function (dist) {\n    if (dist === void 0) {\n      dist = 150;\n    }\n    this.distActual = dist;\n    this.distTarget = dist;\n  };\n  Binocs.prototype.setRotation = function (_rotX, _rotY, _rotZ) {\n    if (_rotX === void 0) {\n      _rotX = 0;\n    }\n    if (_rotY === void 0) {\n      _rotY = 0;\n    }\n    if (_rotZ === void 0) {\n      _rotZ = 0;\n    }\n    this.rotActual.set(_rotX, _rotY, _rotZ);\n    this.rotTarget.set(_rotX, _rotY, _rotZ);\n    this.gyro.alpha = undefined;\n    this.gyro.beta = undefined;\n    this.gyro.gamma = undefined;\n  };\n  Binocs.prototype.setFocusPos = function (_posX, _posY, _posZ) {\n    if (_posX === void 0) {\n      _posX = 0;\n    }\n    if (_posY === void 0) {\n      _posY = 0;\n    }\n    if (_posZ === void 0) {\n      _posZ = 0;\n    }\n    this.focusActual.set(_posX, _posY, _posZ);\n    this.focusTarget.set(_posX, _posY, _posZ);\n  };\n  Binocs.prototype.dolly = function (distance) {\n    this.distTarget += distance / 100;\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\n  };\n  Binocs.prototype.orbitBy = function (angleX, angleY) {\n    this.rotTarget.x += angleX;\n    this.rotTarget.y += angleY;\n  };\n  Binocs.prototype.orbitTo = function (angleX, angleY) {\n    this.rotTarget.x = angleX;\n    this.rotTarget.y = angleY;\n  };\n  Binocs.prototype.pan = function (distX, distY) {\n    this.focusTarget.x -= distX / 10;\n    this.focusTarget.y += distY / 10;\n  };\n  Binocs.prototype.onWindowResize = function (vpW, vpH) {\n    this.vpW = vpW;\n    this.vpH = vpH;\n    this.lensL.aspect = this.vpW / 2 / this.vpH;\n    this.lensL.updateProjectionMatrix();\n    this.lensR.aspect = this.vpW / 2 / this.vpH;\n    this.lensR.updateProjectionMatrix();\n    this.vignetteL.scale.set(this.vpW / 2 / this.vpH, 1, 1);\n    this.vignetteR.scale.set(this.vpW / 2 / this.vpH, 1, 1);\n  };\n  Binocs.prototype.onDeviceReorientation = function (orientation) {\n    this.gyro.orient = orientation * this.radians;\n  };\n  Binocs.prototype.onGyroMove = function (alpha, beta, gamma) {\n    var acc = this.gyro;\n    acc.alpha = alpha;\n    acc.beta = beta;\n    acc.gamma = gamma;\n  };\n  Binocs.prototype.update = function () {\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\n    this.distActual += (this.distTarget - this.distActual) * 0.01;\n    this.focusActual.lerp(this.focusTarget, 0.05);\n    this.binoculars.position.copy(this.focusActual);\n    if (this.gyro.alpha && this.gyro.beta && this.gyro.gamma) {\n      this.binoculars.setRotationFromEuler(this.defaultEuler);\n      this.binoculars.rotateZ(this.gyro.alpha * this.radians);\n      this.binoculars.rotateX(this.gyro.beta * this.radians);\n      this.binoculars.rotateY(this.gyro.gamma * this.radians);\n      this.binoculars.rotation.z += this.gyro.orient;\n    } else {\n      this.rotActual.lerp(this.rotTarget, 0.05);\n      this.quatX.setFromAxisAngle(Binocs.axisX, -THREE.Math.degToRad(this.rotActual.y));\n      this.quatY.setFromAxisAngle(Binocs.axisY, -THREE.Math.degToRad(this.rotActual.x));\n      this.quatY.multiply(this.quatX);\n      this.binoculars.quaternion.copy(this.quatY);\n    }\n    this.binoculars.translateZ(this.distActual);\n  };\n  Binocs.prototype.renderStereo = function (renderer, scene) {\n    renderer.setScissor(0, 0, this.vpW / 2, this.vpH);\n    renderer.setViewport(0, 0, this.vpW / 2, this.vpH);\n    renderer.render(scene, this.lensL);\n    renderer.setScissor(this.vpW / 2, 0, this.vpW / 2, this.vpH);\n    renderer.setViewport(this.vpW / 2, 0, this.vpW / 2, this.vpH);\n    renderer.render(scene, this.lensR);\n  };\n  Binocs.axisX = new THREE.Vector3(1, 0, 0);\n  Binocs.axisY = new THREE.Vector3(0, 1, 0);\n  return Binocs;\n}();\nexports.default = Binocs;\n\n//# sourceURL=webpack:///./src/Utility/Binocs.ts?");

/***/ }),

/***/ "./src/Utility/Raycaster.ts":
/*!**********************************!*\
  !*** ./src/Utility/Raycaster.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Ray = function () {\n  function Ray(_cam) {\n    this.cam = _cam;\n    this.ray = new THREE.Raycaster();\n\n    this.geom = new THREE.PlaneBufferGeometry(64, 64);\n    this.geom.rotateX(-Math.PI / 2);\n\n    this.mat = new THREE.MeshStandardMaterial();\n    this.plane = new THREE.Mesh(this.geom, this.mat);\n  }\n  \n  Ray.prototype.rayCast = function (mouse) {\n    this.ray.setFromCamera(mouse, this.cam);\n    \n    var intersects = this.ray.intersectObject(this.plane);\n\n    if (typeof intersects[0] !== 'undefined') {\n      return intersects[0].point;\n    } else {\n      return false;\n    }\n  };\n\n  return Ray;\n\n}();\n\nexports.default = Ray;\n\n//# sourceURL=webpack:///./src/Utility/Raycaster.ts?");

/***/ }),

/***/ "./src/Utility/RippleGenerator.ts":
/*!****************************************!*\
  !*** ./src/Utility/RippleGenerator.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar rawVert = __webpack_require__(/*! ../Shaders/RawVertical */ \"./src/Shaders/RawVertical.ts\");\nvar hmFrag = __webpack_require__(/*! ../Shaders/HMFragment */ \"./src/Shaders/HMFragment.ts\");\n\nvar RippleGen = function () {\n  function RippleGen(_renderer, mouse, _gridSize) {\n    if (_gridSize === void 0) {\n      _gridSize = 64;\n    }\n\n    this.renderChange = false;\n    this.devMode = false;\n    this.renderer = _renderer;\n    this.textureSize = _gridSize;\n\n    var dataType = /(iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n\n    this.rTarget1 = new THREE.WebGLRenderTarget(this.textureSize, this.textureSize, {\n      minFilter: THREE.NearestFilter,\n      magFilter: THREE.NearestFilter,\n      stencilBuffer: false,\n      depthBuffer: false,\n      format: THREE.RGBAFormat,\n      type: dataType,\n      wrapS: THREE.RepeatWrapping,\n      wrapT: THREE.RepeatWrapping\n    });\n\n    this.rTarget2 = this.rTarget1.clone();\n    this.gpScene = new THREE.Scene();\n    this.gpCam = new THREE.Camera();\n    this.gpCam.position.z = 1;\n\n    var rezString = 'vec2( ' + this.textureSize.toFixed(1) + ', ' + this.textureSize.toFixed(1) + ' )';\n\n    this.gpGeom = new THREE.PlaneBufferGeometry(2, 2);\n    this.gpMat = new THREE.RawShaderMaterial({\n      uniforms: {\n        ripplePos: {\n          value: mouse\n        },\n        rippleSize: {\n          value: 1\n        },\n        rippleImpact: {\n          value: 1\n        },\n        viscosity: {\n          value: 0.01\n        },\n        heightmap: {\n          value: null\n        }\n      },\n      defines: {\n        BOUNDS: this.textureSize.toFixed(1),\n        resolution: rezString\n      },\n      vertexShader: rawVert,\n      fragmentShader: hmFrag,\n      depthWrite: false\n    });\n\n    this.uniSize = this.gpMat.uniforms['rippleSize'];\n    this.uniImpact = this.gpMat.uniforms['rippleImpact'];\n    this.gpMesh = new THREE.Mesh(this.gpGeom, this.gpMat);\n    this.gpScene.add(this.gpMesh);\n\n    if (this.devMode) {\n      this.devScene = new THREE.Scene();\n      this.devCam = new THREE.Camera();\n      this.devCam.position.z = 1;\n      this.devGeom = new THREE.PlaneBufferGeometry(2, 2);\n      this.devMat = new THREE.MeshBasicMaterial({\n        map: this.rTarget1.texture\n      });\n      this.devMesh = new THREE.Mesh(this.devGeom, this.devMat);\n      this.devScene.add(this.devMesh);\n    }\n  }\n\n  RippleGen.prototype.newRippleSize = function (_size) {\n    this.uniSize.value = _size;\n  };\n\n  RippleGen.prototype.newRippleImpact = function (_val) {\n    this.uniImpact.value = _val;\n  };\n\n  RippleGen.prototype.update = function () {\n    this.renderChange = !this.renderChange;\n    if (this.renderChange) {\n      this.gpMat.uniforms['heightmap'].value = this.rTarget2.texture;\n      this.renderer.render(this.gpScene, this.gpCam, this.rTarget1);\n\n      if (this.devMode) {\n        this.renderer.setViewport(0, 0, this.textureSize * 2, this.textureSize * 2);\n        this.renderer.render(this.devScene, this.devCam);\n        this.renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);\n      }\n\n      return this.rTarget1.texture;\n    } else {\n      this.gpMat.uniforms['heightmap'].value = this.rTarget1.texture;\n      this.renderer.render(this.gpScene, this.gpCam, this.rTarget2);\n\n      if (this.devMode) {\n        this.renderer.setViewport(0, 0, this.textureSize * 2, this.textureSize * 2);\n        this.renderer.render(this.devScene, this.devCam);\n        this.renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);\n      }\n\n      return this.rTarget2.texture;\n    }\n  };\n\n  return RippleGen;\n}();\n\nexports.default = RippleGen;\n\n//# sourceURL=webpack:///./src/Utility/RippleGenerator.ts?");

/***/ }),

/***/ "./src/Utility/Utils.ts":
/*!******************************!*\
  !*** ./src/Utility/Utils.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction normalize(val, min, max) {\n  return Math.max(0, Math.min(1, (val - min) / (max - min)));\n}\n\nexports.normalize = normalize;\n\nfunction normalizeQuadIn(val, min, max) {\n  return Math.pow(normalize(val, min, max), 2);\n}\n\nexports.normalizeQuadIn = normalizeQuadIn;\n\nfunction normalizeQuadOut(val, min, max) {\n  var x = normalize(val, min, max);\n  return x * (2 - x);\n}\n\nexports.normalizeQuadOut = normalizeQuadOut;\n\nfunction zTween(_val, _target, _ratio) {\n  return _val + (_target - _val) * Math.min(_ratio, 1);\n}\n\nexports.zTween = zTween;\n\nvar Time = function () {\n  function Time(timeFactor) {\n    this.fallBackRates = [\n      60,\n      40,\n      30,\n      20,\n      15\n    ];\n\n    this.prev = 0;\n    this.prevBreak = 0;\n    this.delta = 0;\n    this.timeFact = typeof timeFactor === 'undefined' ? 1 : timeFactor;\n    this.frameCount = 0;\n    this.fallBackIndex = 0;\n\n    this.setFPS(60);\n  }\n\n  Time.prototype.update = function (_newTime) {\n    this.deltaBreak = Math.min(_newTime - this.prevBreak, 1);\n\n    if (this.deltaBreak > this.spf) {\n      this.delta = Math.min(_newTime - this.prev, 1);\n      this.prev = _newTime;\n      this.prevBreak = _newTime - this.deltaBreak % this.spf;\n      \n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  Time.prototype.checkFPS = function () {\n    if (this.delta > this.spf * 2) {\n      this.frameCount++;\n\n      console.log(this.frameCount);\n\n      if (this.frameCount > 30) {\n        this.frameCount = 0;\n        this.fallBackIndex++;\n\n        this.setFPS(this.fallBackRates[this.fallBackIndex]);\n      }\n    }\n  };\n\n  Time.prototype.setFPS = function (_newVal) {\n    this.fps = _newVal;\n    this.spf = 1 / this.fps;\n  };\n  \n  return Time;\n}();\n\nexports.Time = Time;\n\nfunction shuffle(array) {\n  var m = array.length,\n    t, i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n\nexports.shuffle = shuffle;\n\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n\nexports.mod = mod;\n\n//# sourceURL=webpack:///./src/Utility/Utils.ts?");

/***/ })

/******/ });