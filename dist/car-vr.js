/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Init.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Car/CarBody.ts":
/*!****************************!*\
  !*** ./src/Car/CarBody.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar CarWheels_1 = __webpack_require__(/*! ./CarWheels */ \"./src/Car/CarWheels.ts\");\r\nvar CarLights_1 = __webpack_require__(/*! ./CarLights */ \"./src/Car/CarLights.ts\");\r\n\r\nvar CarBody = function () {\r\n\r\n  function CarBody(_scene, _cargo) {\r\n    this.parent = _scene;\r\n\r\n    this.carWhole = new THREE.Group();\r\n    this.carWhole.rotateY(-Math.PI / 2);\r\n\r\n    this.parent.add(this.carWhole);\r\n    this.carChassis = this.buildCarChassis(_cargo['vrBodyCompiled'], _cargo['envReflection']);\r\n    this.carWhole.add(this.carChassis);\r\n    this.addShadow(_cargo['shadow']);\r\n\r\n    this.carLights = new CarLights_1.default(this.carChassis, _cargo);\r\n    this.carWheels = new CarWheels_1.default(this.carWhole, _cargo);\r\n  }\r\n\r\n  CarBody.prototype.buildCarChassis = function (_bodyGeom, _cubeText) {\r\n    _bodyGeom.scale.set(0.0005, 0.0005, 0.0005);\r\n    _bodyGeom.position.set(1.56, 0, 0);\r\n    this.envCube = _cubeText;\r\n    this.envCube.format = THREE.RGBFormat;\r\n    this.matBodySilver = new THREE.MeshStandardMaterial({\r\n      color: 0x5f27cd,\r\n      metalness: 0.7,\r\n      roughness: 0.7,\r\n      envMap: this.envCube\r\n    });\r\n\r\n    if (window['EXT_STLOD_SUPPORT'] === false) {\r\n      this.envCube.minFilter = THREE.LinearFilter;\r\n      this.matBodySilver.metalness = 0.05;\r\n      this.matBodySilver.roughness = 0.8;\r\n      this.matBodySilver.color = new THREE.Color(0x777777);\r\n    }\r\n\r\n    this.matBodyBlack = new THREE.MeshLambertMaterial({\r\n      color: 0x2D3436,\r\n      emissive: 0x444444,\r\n      reflectivity: 0.8,\r\n      envMap: this.envCube\r\n    });\r\n\r\n    this.matGlassTinted = new THREE.MeshLambertMaterial({\r\n      color: 0x000000,\r\n      emissive: 0x666666,\r\n      reflectivity: 1,\r\n      envMap: this.envCube\r\n    });\r\n\r\n    this.matUndercarriage = new THREE.MeshBasicMaterial({\r\n      color: 0x000000\r\n    });\r\n\r\n    this.matGlassTransp = new THREE.MeshLambertMaterial({\r\n      color: 0x000000,\r\n      emissive: 0x666666,\r\n      reflectivity: 1,\r\n      envMap: this.envCube,\r\n      transparent: true,\r\n      blending: THREE.AdditiveBlending\r\n    });\r\n\r\n    _bodyGeom.getObjectByName('BodyBlack').material = this.matBodyBlack;\r\n    _bodyGeom.getObjectByName('BodySilver').material = this.matBodySilver;\r\n    _bodyGeom.getObjectByName('GlassTransparent').material = this.matGlassTransp;\r\n    _bodyGeom.getObjectByName('GlassTinted').material = this.matGlassTinted;\r\n    _bodyGeom.getObjectByName('Undercarriage').material = this.matUndercarriage;\r\n\r\n    return _bodyGeom;\r\n  };\r\n\r\n  CarBody.prototype.addShadow = function (_shad) {\r\n    var shadowPlane = new THREE.PlaneBufferGeometry(6.5, 6.5, 1, 1);\r\n    shadowPlane.rotateX(-Math.PI / 2);\r\n    shadowPlane.translate(1.56, 0, 0);\r\n\r\n    var shadowMat = new THREE.MeshBasicMaterial({\r\n      map: _shad,\r\n      side: THREE.DoubleSide,\r\n      blending: THREE.MultiplyBlending,\r\n      transparent: true,\r\n      depthWrite: false\r\n    });\r\n\r\n    var shadowMesh = new THREE.Mesh(shadowPlane, shadowMat);\r\n    this.carWhole.add(shadowMesh);\r\n  };\r\n\r\n  CarBody.prototype.onWindowResize = function (_vpH) {\r\n    this.carLights.onWindowResize(_vpH);\r\n  };\r\n\r\n  CarBody.prototype.update = function (_props) {\r\n    this.carWhole.rotation.y = _props.theta;\r\n    this.carChassis.rotation.z = _props.longitMomentum * 0.0015;\r\n    this.carChassis.rotation.x = _props.lateralMomentum * 0.002;\r\n    this.carWheels.update(_props);\r\n    this.carLights.update(_props);\r\n  };\r\n  return CarBody;\r\n}();\r\n\r\nexports.default = CarBody;\n\n//# sourceURL=webpack:///./src/Car/CarBody.ts?");

/***/ }),

/***/ "./src/Car/CarLights.ts":
/*!******************************!*\
  !*** ./src/Car/CarLights.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar headgridVS = __webpack_require__(/*! ../Shaders/HeadGridVS */ \"./src/Shaders/HeadGridVS.ts\");\r\nvar headgridFS = __webpack_require__(/*! ../Shaders/headgridFS */ \"./src/Shaders/headgridFS.ts\");\r\nvar tailLightVS = __webpack_require__(/*! ../Shaders/tailLightVS */ \"./src/Shaders/tailLightVS.ts\");\r\nvar tailGridVS = __webpack_require__(/*! ../Shaders/tailGridVS */ \"./src/Shaders/tailGridVS.ts\");\r\nvar tailGridFS = __webpack_require__(/*! ../Shaders/tailGridFS */ \"./src/Shaders/tailGridFS.ts\");\r\nvar flareVS = __webpack_require__(/*! ../Shaders/FlareVS */ \"./src/Shaders/FlareVS.ts\");\r\nvar flareFS = __webpack_require__(/*! ../Shaders/FlareFS */ \"./src/Shaders/FlareFS.ts\");\r\nvar turnBarVS = __webpack_require__(/*! ../Shaders/turnBarVS */ \"./src/Shaders/turnBarVS.ts\");\r\nvar reverseBarVS = __webpack_require__(/*! ../Shaders/reverseBarVS */ \"./src/Shaders/reverseBarVS.ts\");\r\nvar reverseGridFS = __webpack_require__(/*! ../Shaders/ReverseGridFS */ \"./src/Shaders/ReverseGridFS.ts\");\r\nvar stopBarVS = __webpack_require__(/*! ../Shaders/stopBarVS */ \"./src/Shaders/stopBarVS.ts\");\r\nvar turnBarFS = __webpack_require__(/*! ../Shaders/turnBarFS */ \"./src/Shaders/turnBarFS.ts\");\r\n\r\nvar CarLights = function () {\r\n  function CarLights(_carChassis, _cargo) {\r\n    this.lfTimer = 0;\r\n    this.rtTimer = 0;\r\n    this.carChassis = _carChassis;\r\n    this.flareHeadText = _cargo['flareHead'];\r\n    this.flareTurnText = _cargo['flareTurn'];\r\n    this.glowTurnText = _cargo['lightTurn'];\r\n    this.glowStopText = _cargo['lightStop'];\r\n    this.glowReverseText = _cargo['lightReverse'];\r\n    this.uniLightsTurn = new THREE.Vector3(0, 0, 0);\r\n    this.uniLightsOther = new THREE.Vector3(0, 1, 0);\r\n    this.initLightMeshes();\r\n    this.initHeadlightFlares();\r\n    this.initStopFlares();\r\n    this.initReverseFlares();\r\n    this.initTurnFlares();\r\n  }\r\n\r\n  CarLights.prototype.initLightMeshes = function () {\r\n    var tailGrid = this.carChassis.getObjectByName('TailGrid');\r\n\r\n    tailGrid.geometry.computeVertexNormals();\r\n\r\n    this.matHeadLights = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        lightsT: {\r\n          value: this.uniLightsTurn\r\n        },\r\n        lightsO: {\r\n          value: this.uniLightsOther\r\n        }\r\n      },\r\n      vertexShader: headgridVS,\r\n      fragmentShader: headgridFS\r\n    });\r\n\r\n    this.matTailLights = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        lightsT: {\r\n          value: this.uniLightsTurn\r\n        },\r\n        lightsO: {\r\n          value: this.uniLightsOther\r\n        }\r\n      },\r\n      vertexShader: tailLightVS,\r\n      fragmentShader: tailGridFS\r\n    });\r\n\r\n    this.matTailGrid = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        lightsT: {\r\n          value: this.uniLightsTurn\r\n        },\r\n        lightsO: {\r\n          value: this.uniLightsOther\r\n        }\r\n      },\r\n      vertexShader: tailGridVS,\r\n      fragmentShader: tailGridFS\r\n    });\r\n\r\n    this.carChassis.getObjectByName('HeadLights').material = this.matHeadLights;\r\n    this.carChassis.getObjectByName('TailLights').material = this.matTailLights;\r\n    tailGrid.material = this.matTailGrid;\r\n  };\r\n\r\n  CarLights.prototype.initHeadlightFlares = function () {\r\n    this.flareHeadMat = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        texture: {\r\n          value: this.flareHeadText\r\n        },\r\n        vpH: {\r\n          value: window.innerHeight\r\n        },\r\n        size: {\r\n          value: 1.5\r\n        },\r\n        brightness: {\r\n          value: 1\r\n        }\r\n      },\r\n      vertexShader: flareVS,\r\n      fragmentShader: flareFS,\r\n      blending: THREE.AdditiveBlending,\r\n      transparent: true,\r\n      depthTest: false\r\n    });\r\n\r\n    var posArray = new Float32Array([\r\n      4000,\r\n      1875,\r\n      1700,\r\n      4300,\r\n      1800,\r\n      1700,\r\n      4000,\r\n      1875,\r\n      -1700,\r\n      4300,\r\n      1800,\r\n      -1700\r\n    ]);\r\n\r\n    var normArray = new Float32Array([\r\n      0.87,\r\n      0.22,\r\n      0.44,\r\n      0.87,\r\n      0.22,\r\n      0.44,\r\n      0.87,\r\n      0.22,\r\n      -0.44,\r\n      0.87,\r\n      0.22,\r\n      -0.44\r\n    ]);\r\n\r\n    this.flareHeadGeom = new THREE.BufferGeometry();\r\n    this.flareHeadGeom.addAttribute('position', new THREE.BufferAttribute(posArray, 3));\r\n    this.flareHeadGeom.addAttribute('normal', new THREE.BufferAttribute(normArray, 3));\r\n    this.flareHeadPoints = new THREE.Points(this.flareHeadGeom, this.flareHeadMat);\r\n    this.carChassis.add(this.flareHeadPoints);\r\n  };\r\n\r\n  CarLights.prototype.initStopFlares = function () {\r\n    var glowStopMat = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        texture: {\r\n          value: this.glowStopText\r\n        }\r\n      },\r\n      vertexShader: stopBarVS,\r\n      fragmentShader: turnBarFS,\r\n      blending: THREE.AdditiveBlending,\r\n      transparent: true,\r\n      depthTest: false\r\n    });\r\n\r\n    this.glowStop = this.carChassis.getObjectByName('Stop');\r\n    this.glowStop.material = glowStopMat;\r\n  };\r\n\r\n  CarLights.prototype.initReverseFlares = function () {\r\n    var glowReverseMat = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        texture: {\r\n          value: this.glowReverseText\r\n        }\r\n      },\r\n      vertexShader: reverseBarVS,\r\n      fragmentShader: reverseGridFS,\r\n      blending: THREE.AdditiveBlending,\r\n      transparent: true,\r\n      depthTest: false\r\n    });\r\n\r\n    this.glowReverse = this.carChassis.getObjectByName('Reverse');\r\n    this.glowReverse.material = glowReverseMat;\r\n  };\r\n\r\n  CarLights.prototype.initTurnFlares = function () {\r\n    var posArray = new Float32Array([\r\n      -4755,\r\n      2227,\r\n      -1269,\r\n      -4703,\r\n      2222,\r\n      -1326,\r\n      -4649,\r\n      2215,\r\n      -1381,\r\n      -4590,\r\n      2208,\r\n      -1436,\r\n      -4526,\r\n      2200,\r\n      -1492,\r\n      -4459,\r\n      2192,\r\n      -1548,\r\n      -4386,\r\n      2182,\r\n      -1604,\r\n      -4718,\r\n      2182,\r\n      -1264,\r\n      -4668,\r\n      2179,\r\n      -1321,\r\n      -4301,\r\n      2175,\r\n      -1658,\r\n      -4614,\r\n      2175,\r\n      -1377,\r\n      -4556,\r\n      2168,\r\n      -1433,\r\n      -4494,\r\n      2163,\r\n      -1489,\r\n      -4429,\r\n      2158,\r\n      -1545,\r\n      -4358,\r\n      2151,\r\n      -1600,\r\n      -4266,\r\n      2147,\r\n      -1653,\r\n      -4675,\r\n      2136,\r\n      -1260,\r\n      -4627,\r\n      2134,\r\n      -1316,\r\n      -4575,\r\n      2132,\r\n      -1373,\r\n      -4520,\r\n      2130,\r\n      -1428,\r\n      -4461,\r\n      2128,\r\n      -1485,\r\n      -4400,\r\n      2126,\r\n      -1540,\r\n      -4329,\r\n      2123,\r\n      -1597\r\n    ]);\r\n\r\n    var normArray = new Float32Array([\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4,\r\n      -0.9,\r\n      0,\r\n      -0.4\r\n    ]);\r\n\r\n    this.flareTurnMat = this.flareHeadMat.clone();\r\n    this.flareTurnMat.uniforms['texture'].value = this.flareTurnText;\r\n    this.flareTurnMat.uniforms['size'].value = 0.05;\r\n    this.flareTurnMat.uniforms['brightness'].value = 1;\r\n\r\n    var leftTurnGrid = new THREE.BufferGeometry();\r\n\r\n    leftTurnGrid.addAttribute('position', new THREE.BufferAttribute(posArray, 3));\r\n    leftTurnGrid.addAttribute('normal', new THREE.BufferAttribute(normArray, 3));\r\n\r\n    this.flareLPoints = new THREE.Points(leftTurnGrid, this.flareTurnMat);\r\n    this.carChassis.add(this.flareLPoints);\r\n\r\n    posArray = new Float32Array([\r\n      -4755,\r\n      2227,\r\n      1269,\r\n      -4703,\r\n      2222,\r\n      1326,\r\n      -4649,\r\n      2215,\r\n      1381,\r\n      -4590,\r\n      2208,\r\n      1436,\r\n      -4526,\r\n      2200,\r\n      1492,\r\n      -4459,\r\n      2192,\r\n      1548,\r\n      -4386,\r\n      2182,\r\n      1604,\r\n      -4718,\r\n      2182,\r\n      1264,\r\n      -4668,\r\n      2179,\r\n      1321,\r\n      -4301,\r\n      2175,\r\n      1658,\r\n      -4614,\r\n      2175,\r\n      1377,\r\n      -4556,\r\n      2168,\r\n      1433,\r\n      -4494,\r\n      2163,\r\n      1489,\r\n      -4429,\r\n      2158,\r\n      1545,\r\n      -4358,\r\n      2151,\r\n      1600,\r\n      -4266,\r\n      2147,\r\n      1653,\r\n      -4675,\r\n      2136,\r\n      1260,\r\n      -4627,\r\n      2134,\r\n      1316,\r\n      -4575,\r\n      2132,\r\n      1373,\r\n      -4520,\r\n      2130,\r\n      1428,\r\n      -4461,\r\n      2128,\r\n      1485,\r\n      -4400,\r\n      2126,\r\n      1540,\r\n      -4329,\r\n      2123,\r\n      1597\r\n    ]);\r\n\r\n    normArray = new Float32Array([\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4,\r\n      -0.9,\r\n      0,\r\n      0.4\r\n    ]);\r\n\r\n    var rightTurnGrid = new THREE.BufferGeometry();\r\n\r\n    rightTurnGrid.addAttribute('position', new THREE.BufferAttribute(posArray, 3));\r\n    rightTurnGrid.addAttribute('normal', new THREE.BufferAttribute(normArray, 3));\r\n\r\n    this.flareRPoints = new THREE.Points(rightTurnGrid, this.flareTurnMat);\r\n    this.carChassis.add(this.flareRPoints);\r\n\r\n    this.glowTurnMat = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        texture: {\r\n          value: this.glowTurnText\r\n        },\r\n        lightsT: {\r\n          value: this.uniLightsTurn\r\n        }\r\n      },\r\n      vertexShader: turnBarVS,\r\n      fragmentShader: turnBarFS,\r\n      blending: THREE.AdditiveBlending,\r\n      transparent: true,\r\n      depthTest: false\r\n    });\r\n\r\n    this.carChassis.getObjectByName('Turn').material = this.glowTurnMat;\r\n  };\r\n\r\n  CarLights.prototype.onWindowResize = function (_vpH) {\r\n    this.flareHeadMat.uniforms['vpH'].value = _vpH;\r\n    this.flareTurnMat.uniforms['vpH'].value = _vpH;\r\n  };\r\n\r\n  CarLights.prototype.update = function (_props) {\r\n    if (_props.wAngleTarg > 0) {\r\n      this.lfTimer = (this.lfTimer + _props.time.delta * 2) % 2;\r\n      this.uniLightsTurn.y = this.lfTimer > 1 ? 0 : 1;\r\n      this.uniLightsTurn.z = 0;\r\n      this.uniLightsTurn.x = -1;\r\n    } else if (_props.wAngleTarg < 0) {\r\n      this.rtTimer = (this.rtTimer + _props.time.delta * 2) % 2;\r\n      this.uniLightsTurn.z = this.rtTimer > 1 ? 0 : 1;\r\n      this.uniLightsTurn.y = 0;\r\n      this.uniLightsTurn.x = 1;\r\n    } else {\r\n      this.lfTimer = 0;\r\n      this.rtTimer = 0;\r\n      this.uniLightsTurn.y = 0;\r\n      this.uniLightsTurn.z = 0;\r\n      this.uniLightsTurn.x = 0;\r\n    }\r\n\r\n    this.uniLightsOther.x = 0;\r\n    this.glowStop.visible = _props.braking ? true : false;\r\n    this.glowReverse.visible = _props.gear == -1 ? true : false;\r\n    this.flareLPoints.visible = this.uniLightsTurn.y ? true : false;\r\n    this.flareRPoints.visible = this.uniLightsTurn.z ? true : false;\r\n  };\r\n\r\n  return CarLights;\r\n}();\r\n\r\nexports.default = CarLights;\n\n//# sourceURL=webpack:///./src/Car/CarLights.ts?");

/***/ }),

/***/ "./src/Car/CarProps.ts":
/*!*****************************!*\
  !*** ./src/Car/CarProps.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar utils_1 = __webpack_require__(/*! ../Utility/Utils */ \"./src/Utility/Utils.ts\");\r\n\r\nvar Automotive = function () {\r\n  function Automotive() {}\r\n  Automotive.Force = 1800;\r\n  Automotive.Accel = 10;\r\n  Automotive.Decel = -5;\r\n  Automotive.MaxVel = 70 * 1610 / 3600;\r\n  Automotive.MaxTurn = Math.PI * 0.33;\r\n  Automotive.Length = 5.25;\r\n  Automotive.Width = 2.283;\r\n  Automotive.WheelTrack = 1.72;\r\n  Automotive.WheelBase = 3.2;\r\n  Automotive.WheelDiam = 0.78;\r\n  Automotive.WheelCirc = Automotive.WheelDiam * Math.PI;\r\n  Automotive.Weight = 3198;\r\n  return Automotive;\r\n}();\r\n\r\nexports.Automotive = Automotive;\r\n\r\nvar CarProps = function () {\r\n  function CarProps() {\r\n    this.time = new utils_1.Time();\r\n    this.velocity = new THREE.Vector2();\r\n    this.speed = 0;\r\n    this.accel = 0;\r\n    this.gear = 1;\r\n    this.pos = new THREE.Vector2();\r\n    this.joyVec = new THREE.Vector2();\r\n\r\n    // Momentum\r\n    this.longitMomentum = 0;\r\n    this.lateralMomentum = 0;\r\n    this.wAngleInner = 0;\r\n    this.wAngleOuter = 0;\r\n    this.wAngleTarg = 0;\r\n    this.keys = new Array();\r\n    this.braking = 0;\r\n    this.omega = 0;\r\n    this.theta = -Math.PI / 2;\r\n  }\r\n\r\n  CarProps.prototype.onKeyDown = function (evt) {\r\n    // Add key to list if they don't exist yet\r\n    if (this.keys.indexOf(evt.keyCode) === -1)\r\n      this.keys.push(evt.keyCode);\r\n  };\r\n\r\n  CarProps.prototype.onKeyUp = function (evt) {\r\n    //Otherwise, remove from keys list\r\n    this.keys.splice(this.keys.indexOf(evt.keyCode), 1);\r\n  };\r\n\r\n  CarProps.prototype.readKeyboardInput = function () {\r\n    for (var i = 0; i < this.keys.length; i++) {\r\n      switch (this.keys[i]) {\r\n\r\n        case 17: // CTRL - Shift Down\r\n          if ((this.speed * 3.6) < 5.314815 && this.gear != -1) {\r\n            this.gear = -1;\r\n          } else {\r\n            if (this.gear > 0)\r\n              this.gear--;\r\n          }\r\n          break;\r\n\r\n        case 16: // SHIFT - Shift Up\r\n          if (this.gear == -1 && this.speed * 3.6 < 5.314815)\r\n            this.gear++;\r\n          if (this.gear > 0 && this.gear < 6)\r\n            this.gear++;\r\n\r\n          break;\r\n\r\n        case 38: // Up\r\n          if (this.gear > -1) {\r\n            this.accel += Automotive.Accel;\r\n\r\n            // Simulate wind resistance as we reach top speed\r\n            this.accel *= utils_1.normalizeQuadIn(this.speed, Automotive.MaxVel, Automotive.MaxVel - 10);\r\n          } else {\r\n            this.accel += Automotive.Decel / 1.2;\r\n            this.braking = 1;\r\n          }\r\n\r\n          break;\r\n\r\n        case 40: // Down\r\n          if (this.gear == -1) {\r\n            this.accel += Automotive.Accel;\r\n            this.accel *= utils_1.normalizeQuadIn(this.speed, Automotive.MaxVel / Math.PI, Automotive.MaxVel / Math.PI - 10);\r\n          } else {\r\n            this.accel += Automotive.Decel / 1.2;\r\n            this.braking = 1;\r\n          }\r\n\r\n          break;\r\n\r\n        case 32: // Space\r\n          this.accel += Automotive.Decel;\r\n          this.braking = 1;\r\n\r\n          break;\r\n\r\n        case 37: { // Left\r\n          const omegaAxle = 0.6;\r\n          const omegaMg = 0.4;\r\n\r\n          /*!  \r\n           *  Variables:\r\n           *      F - Friction\r\n           *      m - Weight\r\n           *      g - acceleration\r\n           *      R - Axle Force\r\n           *      W - Number of Wheels\r\n           *      F^fr^max - ~decceleration\r\n           * \r\n           *  Constants:\r\n           *      u^s = 0.6\r\n           *      u^k = 0.4\r\n           * \r\n           *  Formula:\r\n           *      F = (((m / R) * g) * u^s * u^k) - 4) * F^fr^max\r\n           *      \r\n           */\r\n          const decceleration = (Automotive.Weight / Automotive.Force * Automotive.Accel * omegaAxle * omegaMg - 4) * Automotive.Decel;\r\n          \r\n          this.accel += decceleration - Automotive.MaxTurn;\r\n\r\n          this.wAngleTarg += Automotive.MaxTurn;\r\n\r\n          break;\r\n        }\r\n\r\n        case 39: { // Right\r\n\r\n          const omegaAxle = 0.6;\r\n          const omegaMg = 0.4;\r\n          const decceleration = (Automotive.Weight / Automotive.Force * Automotive.Accel * omegaAxle * omegaMg - 4) * Automotive.Decel;\r\n          \r\n          this.accel += decceleration - Automotive.MaxTurn;\r\n\r\n          this.wAngleTarg -= Automotive.MaxTurn;\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  CarProps.prototype.onJoystickMove = function (_vec) {\r\n    this.joyVec.x = _vec.x / -40;\r\n    this.joyVec.y = _vec.y / -40;\r\n\r\n    if (Math.abs(this.joyVec.x) > 0.85) {\r\n      this.joyVec.y = 0;\r\n    }\r\n\r\n    if (Math.abs(this.joyVec.y) > 0.95) {\r\n      this.joyVec.x = 0;\r\n    }\r\n  };\r\n\r\n  CarProps.prototype.readJoyStickInput = function () {\r\n    this.wAngleTarg = this.joyVec.x * Automotive.MaxTurn;\r\n\r\n    //Accelerating\r\n    if (this.joyVec.y >= 0) {\r\n      this.accel = this.joyVec.y * Automotive.Accel;\r\n\r\n      // Simulate wind resistance as we reach top speed\r\n      this.accel *= utils_1.normalizeQuadIn(this.speed, Automotive.MaxVel, Automotive.MaxVel - 10);\r\n      \r\n      this.braking = 0;\r\n    } else {\r\n      this.accel = this.joyVec.y * -Automotive.Decel;\r\n     \r\n      this.braking = 1;\r\n    }\r\n  };\r\n\r\n  /////////////////////////////// UPDATE ///////////////////////////////\r\n  CarProps.prototype.update = function (_time) {\r\n    // Update time, skips according to FPS\r\n    if (this.time.update(_time) === false) {\r\n      return false;\r\n    }\r\n\r\n    this.accel = 0;\r\n    this.braking = 0;\r\n    this.wAngleTarg = 0;\r\n\r\n    if (this.keys.length > 0) {\r\n      this.readKeyboardInput();\r\n    } else if (this.joyVec.x != 0 || this.joyVec.y != 0) {\r\n      this.readJoyStickInput();\r\n    } else if (this.keys.length == 0) {\r\n      const omegaAxle = 0.6;\r\n      const omegaMg = 0.4;\r\n      \r\n      const decceleration = (Automotive.Weight / Automotive.Force * Automotive.Accel * omegaAxle * omegaMg - 4) * Automotive.Decel;\r\n      \r\n      this.accel += decceleration;\r\n    }\r\n\r\n    this.accel *= this.time.delta;\r\n    this.speed += this.accel;\r\n\r\n    let speedometer = document.getElementsByClassName('speedometerSpeed');\r\n    speedometer[0].innerHTML = Math.round(parseInt((this.speed * 3.6).toString())).toString();\r\n    \r\n    ///////////////// PHYSICS, YO! /////////////////\r\n    if (this.speed < 0) {\r\n      this.speed = 0;\r\n      this.accel = 0;\r\n    }\r\n\r\n    this.frameDist = this.speed * this.time.delta;\r\n\r\n    // Limit turn angle as speed increases\r\n    this.wAngleTarg *= utils_1.normalizeQuadIn(this.speed, Automotive.MaxVel + 10, 3);\r\n    this.wAngleInner = utils_1.zTween(this.wAngleInner, this.wAngleTarg, this.time.delta * 2);\r\n    this.wAngleSign = this.wAngleInner > 0.001 ? 1 : this.wAngleInner < -0.001 ? -1 : 0;\r\n\r\n    // Theta is based on speed, wheelbase & wheel angle\r\n    this.omega = this.wAngleInner * this.speed / Automotive.WheelBase;\r\n\r\n    if(this.gear == -1) \r\n      this.theta -= this.omega * this.time.delta;\r\n    else\r\n      this.theta += this.omega * this.time.delta;\r\n\r\n    if (this.gear > -1) {\r\n      // Calc this frame's XY velocity\r\n      this.velocity.set(Math.cos(this.theta) * this.frameDist, -Math.sin(this.theta) * this.frameDist);\r\n      \r\n      // Add velocity to total position\r\n      this.pos.add(this.velocity);\r\n    } else {\r\n      \r\n      // Calc this frame's XY velocity\r\n      this.velocity.set(-Math.cos(this.theta) * this.frameDist, Math.sin(this.theta) * this.frameDist);\r\n\r\n      // Add velocity to total position\r\n      this.pos.add(this.velocity);\r\n    }\r\n\r\n    // Fake some momentum\r\n    this.longitMomentum = utils_1.zTween(this.longitMomentum, this.accel / this.time.delta, this.time.delta * 6);\r\n    this.lateralMomentum = this.omega * this.speed;\r\n\r\n    if (this.wAngleSign) {\r\n        // Calculate 4 wheel turning radius if angle\r\n        this.radFrontIn = Automotive.WheelBase / Math.sin(this.wAngleInner);\r\n        this.radBackIn = Automotive.WheelBase / Math.tan(this.wAngleInner);\r\n        this.radBackOut = this.radBackIn + Automotive.WheelTrack * this.wAngleSign;\r\n        this.wAngleOuter = Math.atan(Automotive.WheelBase / this.radBackOut);\r\n        this.radFrontOut = Automotive.WheelBase / Math.sin(this.wAngleOuter);\r\n    } else {\r\n      // Otherwise, just assign a very large radius.\r\n      this.radFrontOut = 100;\r\n      this.radBackOut = 100;\r\n      this.radBackIn = 100;\r\n      this.radFrontIn = 100;\r\n      this.wAngleOuter = 0;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  return CarProps;\r\n}();\r\n\r\nexports.CarProps = CarProps;\n\n//# sourceURL=webpack:///./src/Car/CarProps.ts?");

/***/ }),

/***/ "./src/Car/CarWheels.ts":
/*!******************************!*\
  !*** ./src/Car/CarWheels.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar CarProps_1 = __webpack_require__(/*! ./CarProps */ \"./src/Car/CarProps.ts\");\r\nvar utils_1 = __webpack_require__(/*! ../Utility/Utils */ \"./src/Utility/Utils.ts\");\r\n\r\nvar CarWheels = function () {\r\n  function CarWheels(_carWhole, _cargo) {\r\n    this.maxWheelTurn = Math.PI / 9.69;\r\n\r\n    this.parent = _carWhole;\r\n    this.thread = _cargo['thread'];\r\n\r\n    this.thread.minFilter = THREE.NearestFilter;\r\n    this.thread.magFilter = THREE.LinearFilter;\r\n    \r\n    this.thread.format = THREE.RGBFormat;\r\n   \r\n    this.ogMatrix = new THREE.Matrix4().set(0.000788, 0, 0, -0.3939, 0, 0, 0.000788, -0.3939, 0, -0.000788, 0, 0.15, 0, 0, 0, 1);\r\n    this.invMatrix = new THREE.Matrix4().set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1);\r\n   \r\n    this.wPosF = CarProps_1.Automotive.WheelBase;\r\n    this.wPosB = 0;\r\n    this.wPosL = CarProps_1.Automotive.WheelTrack / -2;\r\n    this.wPosR = CarProps_1.Automotive.WheelTrack / 2;\r\n    this.wPosY = CarProps_1.Automotive.WheelDiam / 2;\r\n\r\n    var wheelGeom = _cargo['vrWheelBrakes'];\r\n\r\n    this.addLeftWheels(wheelGeom.getObjectByName('Wheel'));\r\n    this.addRightWheels();\r\n    this.addBrakes(wheelGeom.getObjectByName('Brake'));\r\n  }\r\n\r\n  CarWheels.prototype.addLeftWheels = function (_wheelGroup) {\r\n    this.wheelFL = _wheelGroup;\r\n\r\n    this.meshRubber = this.wheelFL.getObjectByName('Tire');\r\n    this.meshSilver = this.wheelFL.getObjectByName('RimsSilver');\r\n    this.meshBlack = this.wheelFL.getObjectByName('RimsBlack');\r\n\r\n    this.geomRubber = this.meshRubber.geometry;\r\n    this.geomSilver = this.meshSilver.geometry;\r\n    this.geomBlack = this.meshBlack.geometry;\r\n\r\n    this.geomRubber.applyMatrix(this.ogMatrix);\r\n    this.geomSilver.applyMatrix(this.ogMatrix);\r\n    this.geomBlack.applyMatrix(this.ogMatrix);\r\n\r\n    this.geomRubber.computeVertexNormals();\r\n    this.geomSilver.computeVertexNormals();\r\n    this.geomBlack.computeVertexNormals();\r\n\r\n    this.matRubber = new THREE.MeshLambertMaterial({\r\n      color: 0x202020,\r\n      map: this.thread\r\n    });\r\n\r\n    this.matSilver = new THREE.MeshPhongMaterial({\r\n      color: 0x999999,\r\n      shininess: 50\r\n    });\r\n\r\n    this.matBlack = new THREE.MeshPhongMaterial({\r\n      color: 0x111111,\r\n      shininess: 50\r\n    });\r\n\r\n    this.meshRubber.material = this.matRubber;\r\n    this.meshSilver.material = this.matSilver;\r\n    this.meshBlack.material = this.matBlack;\r\n\r\n    this.wheelFL.position.set(this.wPosF, this.wPosY, this.wPosL);\r\n\r\n    this.parent.add(this.wheelFL);\r\n\r\n    this.wheelBL = this.wheelFL.clone();\r\n    this.wheelBL.position.set(this.wPosB, this.wPosY, this.wPosL);\r\n\r\n    this.parent.add(this.wheelBL);\r\n  };\r\n\r\n  CarWheels.prototype.addRightWheels = function () {\r\n    this.iGeomRubber = this.geomRubber.clone();\r\n    this.iGeomSilver = this.geomSilver.clone();\r\n    this.iGeomBlack = this.geomBlack.clone();\r\n\r\n    this.iGeomRubber.applyMatrix(this.invMatrix);\r\n    this.iGeomSilver.applyMatrix(this.invMatrix);\r\n    this.iGeomBlack.applyMatrix(this.invMatrix);\r\n\r\n    this.iGeomRubber.computeVertexNormals();\r\n    this.iGeomSilver.computeVertexNormals();\r\n    this.iGeomBlack.computeVertexNormals();\r\n\r\n    var iMatRubber = this.matRubber.clone();\r\n    var iMatSilver = this.matSilver.clone();\r\n    var iMatBlack = this.matBlack.clone();\r\n\r\n    iMatRubber.side = THREE.BackSide;\r\n    iMatSilver.side = THREE.BackSide;\r\n    iMatBlack.side = THREE.BackSide;\r\n\r\n    this.iMeshRubber = new THREE.Mesh(this.iGeomRubber, iMatRubber);\r\n    this.iMeshSilver = new THREE.Mesh(this.iGeomSilver, iMatSilver);\r\n    this.iMeshBlack = new THREE.Mesh(this.iGeomBlack, iMatBlack);\r\n\r\n    this.wheelFR = new THREE.Group();\r\n    this.wheelFR.add(this.iMeshRubber);\r\n    this.wheelFR.add(this.iMeshSilver);\r\n    this.wheelFR.add(this.iMeshBlack);\r\n\r\n    this.wheelFR.position.set(this.wPosF, this.wPosY, this.wPosR);\r\n    this.parent.add(this.wheelFR);\r\n\r\n    this.wheelBR = this.wheelFR.clone();\r\n\r\n    this.wheelBR.position.set(this.wPosB, this.wPosY, this.wPosR);\r\n    this.parent.add(this.wheelBR);\r\n  };\r\n\r\n  CarWheels.prototype.addBrakes = function (_brakeGroup) {\r\n    this.brakeBL = _brakeGroup;\r\n\r\n    this.brMeshDisc = this.brakeBL.getObjectByName('Disc');\r\n    this.brMeshPads = this.brakeBL.getObjectByName('Pad');\r\n\r\n    this.brGeomDisc = this.brMeshDisc.geometry;\r\n    this.brGeomPads = this.brMeshPads.geometry;\r\n\r\n    this.brGeomDisc.applyMatrix(this.ogMatrix);\r\n    this.brGeomPads.applyMatrix(this.ogMatrix);\r\n\r\n    this.brGeomDisc.computeVertexNormals();\r\n    this.brGeomPads.computeVertexNormals();\r\n\r\n    this.brMatDisc = new THREE.MeshPhongMaterial({\r\n      color: 0x555555,\r\n      shininess: 100,\r\n      shading: THREE.FlatShading\r\n    });\r\n\r\n    this.brMatPads = new THREE.MeshPhongMaterial({\r\n      color: 0xD63031,\r\n      shininess: 50,\r\n      shading: THREE.FlatShading\r\n    });\r\n\r\n    this.brMeshDisc.material = this.brMatDisc;\r\n    this.brMeshPads.material = this.brMatPads;\r\n\r\n    this.brakeBL.position.set(this.wPosB, this.wPosY, this.wPosL);\r\n    this.parent.add(this.brakeBL);\r\n\r\n    this.brakeFL = this.brakeBL.clone();\r\n\r\n    this.brakeFL.position.set(this.wPosF, this.wPosY, this.wPosL);\r\n    this.brakeFL.rotation.set(0, 0, Math.PI);\r\n    this.parent.add(this.brakeFL);\r\n\r\n    this.brakeFR = this.brakeBL.clone();\r\n\r\n    this.brakeFR.position.set(this.wPosF, this.wPosY, this.wPosR);\r\n    this.brakeFR.rotation.set(Math.PI, 0, Math.PI);\r\n    this.parent.add(this.brakeFR);\r\n\r\n    this.brakeBR = this.brakeBL.clone();\r\n\r\n    this.brakeBR.position.set(this.wPosB, this.wPosY, this.wPosR);\r\n    this.brakeBR.rotation.set(Math.PI, 0, 0);\r\n    this.parent.add(this.brakeBR);\r\n\r\n  };\r\n\r\n  CarWheels.prototype.addHub = function (xPos, yPos, zPos) {\r\n    var geometry = new THREE.CylinderGeometry(0.15, 0.15, 0.03, 20);\r\n\r\n    geometry.rotateX(Math.PI / 2);\r\n\r\n    var material = new THREE.MeshPhongMaterial({\r\n      color: 0x333333,\r\n      shininess: 50\r\n    });\r\n\r\n    var hubSphere = new THREE.Mesh(geometry, material);\r\n\r\n    hubSphere.position.set(xPos, yPos, zPos);\r\n    this.parent.add(hubSphere);\r\n\r\n    return hubSphere;\r\n  };\r\n\r\n  CarWheels.prototype.turnByRadiusRatio = function (_props) {\r\n    this.rotOverall = -_props.frameDist / CarProps_1.Automotive.WheelCirc * Math.PI * 2;\r\n    this.rotFL = this.rotBL = this.rotFR = this.rotBR = Math.max(this.rotOverall, -this.maxWheelTurn);\r\n\r\n    if (_props.wAngleSign !== 0) {\r\n      this.ratioFO = _props.radFrontOut / _props.radBackIn;\r\n      this.ratioBO = _props.radBackOut / _props.radBackIn;\r\n      this.ratioFI = _props.radFrontIn / _props.radBackIn;\r\n      this.ratioBI = 1;\r\n\r\n      if (_props.wAngleSign == 1) {\r\n        this.rotFL *= this.ratioFI;\r\n        this.rotBL *= this.ratioBI;\r\n        this.rotFR *= this.ratioFO;\r\n        this.rotBR *= this.ratioBO;\r\n\r\n        this.wheelFL.rotation.y = _props.wAngleInner;\r\n        this.wheelFR.rotation.y = _props.wAngleOuter;\r\n        this.brakeFL.rotation.y = _props.wAngleInner;\r\n        this.brakeFR.rotation.y = -_props.wAngleOuter;\r\n      } else {\r\n        this.rotFL *= this.ratioFO;\r\n        this.rotBL *= this.ratioBO;\r\n        this.rotFR *= this.ratioFI;\r\n        this.rotBR *= this.ratioBI;\r\n        \r\n        this.wheelFL.rotation.y = _props.wAngleOuter;\r\n        this.wheelFR.rotation.y = _props.wAngleInner;\r\n        this.brakeFL.rotation.y = _props.wAngleOuter;\r\n        this.brakeFR.rotation.y = -_props.wAngleInner;\r\n      }\r\n\r\n      this.brakeBL.rotation.y = this.wheelBR.rotation.y = this.wheelBL.rotation.y = utils_1.normalize(_props.speed, 22.2, 0) * _props.wAngleInner * -0.09;\r\n      this.brakeBR.rotation.y = -this.wheelBL.rotation.y;\r\n    }\r\n\r\n    this.wheelFL.rotateZ(this.rotFL);\r\n    this.wheelBL.rotateZ(this.rotBL);\r\n    this.wheelFR.rotateZ(this.rotFR);\r\n    this.wheelBR.rotateZ(this.rotBR);\r\n  };\r\n\r\n  CarWheels.prototype.update = function (props) {\r\n    this.turnByRadiusRatio(props);\r\n  };\r\n\r\n  return CarWheels;\r\n}();\r\n\r\nexports.default = CarWheels;\n\n//# sourceURL=webpack:///./src/Car/CarWheels.ts?");

/***/ }),

/***/ "./src/Controls/CameraControl.ts":
/*!***************************************!*\
  !*** ./src/Controls/CameraControl.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar CamControl = function () {\r\n  function CamControl(options) {\r\n    this.options = {\r\n      fov: 45,\r\n      distance: 90,\r\n      distRange: {\r\n        max: Number.POSITIVE_INFINITY,\r\n        min: Number.NEGATIVE_INFINITY\r\n      },\r\n      focusPos: new THREE.Vector3(),\r\n      rotation: new THREE.Vector3(),\r\n      rotRange: {\r\n        xMax: Number.POSITIVE_INFINITY,\r\n        xMin: Number.NEGATIVE_INFINITY,\r\n        yMax: 90,\r\n        yMin: -90\r\n      },\r\n      eyeSeparation: 0\r\n    };\r\n    \r\n    for (var key in options) {\r\n      if (key === 'rotRange') {\r\n        for (var key in options.rotRange) {\r\n          this.options.rotRange[key] = options.rotRange[key];\r\n        }\r\n      } else if (key === 'distRange') {\r\n        for (var key in options.distRange) {\r\n          this.options.distRange[key] = options.distRange[key];\r\n        }\r\n      } else {\r\n        this.options[key] = options[key];\r\n      }\r\n    }\r\n\r\n    this.distActual = this.options.distance;\r\n    this.distTarget = this.options.distance;\r\n\r\n    this.focusActual = this.options.focusPos.clone();\r\n    this.focusTarget = this.options.focusPos.clone();\r\n\r\n    this.rotActual = this.options.rotation.clone();\r\n    this.rotTarget = this.options.rotation.clone();\r\n\r\n    var vpW = window.innerWidth;\r\n    var vpH = window.innerHeight;\r\n\r\n    this.camera = new THREE.PerspectiveCamera(this.options.fov, vpW / vpH, 0.1, 100);\r\n    this.radians = Math.PI / 180;\r\n    \r\n    this.quatX = new THREE.Quaternion();\r\n    this.quatY = new THREE.Quaternion();\r\n    \r\n    this.gyro = {\r\n      orient: 0\r\n    };\r\n\r\n    if (typeof window.orientation !== 'undefined') {\r\n      this.defaultEuler = new THREE.Euler(90 * this.radians, 180 * this.radians, (180 + parseInt(window.orientation.toString(), 10)) * this.radians);\r\n    } else {\r\n      this.defaultEuler = new THREE.Euler(0, 0, 0);\r\n    }\r\n  }\r\n\r\n  CamControl.prototype.setDistance = function (dist) {\r\n    if (dist === void 0) {\r\n      dist = 150;\r\n    }\r\n\r\n    this.distActual = dist;\r\n    this.distTarget = dist;\r\n  };\r\n\r\n  CamControl.prototype.setAngleRange = function (xMax, xMin, yMax, yMin) {\r\n    if (xMax === void 0) {\r\n      xMax = Number.POSITIVE_INFINITY;\r\n    }\r\n\r\n    if (xMin === void 0) {\r\n      xMin = Number.NEGATIVE_INFINITY;\r\n    }\r\n\r\n    if (yMax === void 0) {\r\n      yMax = 90;\r\n    }\r\n\r\n    if (yMin === void 0) {\r\n      yMin = -90;\r\n    }\r\n\r\n    this.options.rotRange.xMax = xMax;\r\n    this.options.rotRange.xMin = xMin;\r\n    this.options.rotRange.yMax = yMax;\r\n    this.options.rotRange.yMin = yMin;\r\n  };\r\n\r\n  CamControl.prototype.setRotation = function (_rotX, _rotY, _rotZ) {\r\n    if (_rotX === void 0) {\r\n      _rotX = 0;\r\n    }\r\n\r\n    if (_rotY === void 0) {\r\n      _rotY = 0;\r\n    }\r\n\r\n    if (_rotZ === void 0) {\r\n      _rotZ = 0;\r\n    }\r\n\r\n    this.rotActual.set(_rotX, _rotY, _rotZ);\r\n    this.rotTarget.set(_rotX, _rotY, _rotZ);\r\n\r\n    this.gyro.alpha = undefined;\r\n    this.gyro.beta = undefined;\r\n    this.gyro.gamma = undefined;\r\n  };\r\n\r\n  CamControl.prototype.setFocusPos = function (_posX, _posY, _posZ) {\r\n    if (_posX === void 0) {\r\n      _posX = 0;\r\n    }\r\n\r\n    if (_posY === void 0) {\r\n      _posY = 0;\r\n    }\r\n\r\n    if (_posZ === void 0) {\r\n      _posZ = 0;\r\n    }\r\n\r\n    this.focusActual.set(_posX, _posY, _posZ);\r\n    this.focusTarget.set(_posX, _posY, _posZ);\r\n  };\r\n\r\n  CamControl.prototype.dolly = function (distance) {\r\n    this.distTarget += distance / 100;\r\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\r\n  };\r\n\r\n  CamControl.prototype.orbitBy = function (angleX, angleY) {\r\n    this.rotTarget.x += angleX;\r\n    this.rotTarget.y += angleY;\r\n    this.rotTarget.x = THREE.Math.clamp(this.rotTarget.x, this.options.rotRange.xMin, this.options.rotRange.xMax);\r\n    this.rotTarget.y = THREE.Math.clamp(this.rotTarget.y, this.options.rotRange.yMin, this.options.rotRange.yMax);\r\n  };\r\n\r\n  CamControl.prototype.orbitTo = function (angleX, angleY) {\r\n    this.rotTarget.x = angleX;\r\n    this.rotTarget.y = angleY;\r\n    this.rotTarget.x = THREE.Math.clamp(this.rotTarget.x, this.options.rotRange.xMin, this.options.rotRange.xMax);\r\n    this.rotTarget.y = THREE.Math.clamp(this.rotTarget.y, this.options.rotRange.yMin, this.options.rotRange.yMax);\r\n  };\r\n\r\n  CamControl.prototype.pan = function (distX, distY) {\r\n    this.focusTarget.x -= distX / 10;\r\n    this.focusTarget.y += distY / 10;\r\n  };\r\n\r\n  CamControl.prototype.onWindowResize = function (vpW, vpH) {\r\n    this.camera.aspect = vpW / vpH;\r\n    this.camera.updateProjectionMatrix();\r\n  };\r\n\r\n  CamControl.prototype.onDeviceReorientation = function (orientation) {\r\n    this.gyro.orient = orientation * this.radians;\r\n  };\r\n  \r\n  CamControl.prototype.onGyroMove = function (alpha, beta, gamma) {\r\n    var acc = this.gyro;\r\n\r\n    acc.alpha = alpha;\r\n    acc.beta = beta;\r\n    acc.gamma = gamma;\r\n  };\r\n\r\n  CamControl.prototype.update = function () {\r\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\r\n    this.distActual += (this.distTarget - this.distActual) * 0.01;\r\n    \r\n    this.focusActual.lerp(this.focusTarget, 0.05);\r\n    this.camera.position.copy(this.focusActual);\r\n\r\n    if (this.gyro.alpha && this.gyro.beta && this.gyro.gamma) {\r\n      this.camera.setRotationFromEuler(this.defaultEuler);\r\n      \r\n      this.camera.rotateZ(this.gyro.alpha * this.radians);\r\n      this.camera.rotateX(this.gyro.beta * this.radians);\r\n      this.camera.rotateY(this.gyro.gamma * this.radians);\r\n\r\n      this.camera.rotation.z += this.gyro.orient;\r\n    } else {\r\n      this.rotActual.lerp(this.rotTarget, 0.05);\r\n\r\n      this.quatX.setFromAxisAngle(CamControl.axisX, -THREE.Math.degToRad(this.rotActual.y));\r\n      this.quatY.setFromAxisAngle(CamControl.axisY, -THREE.Math.degToRad(this.rotActual.x));\r\n      this.quatY.multiply(this.quatX);\r\n\r\n      this.camera.quaternion.copy(this.quatY);\r\n    }\r\n\r\n    this.camera.translateZ(this.distActual);\r\n  };\r\n\r\n  CamControl.prototype.follow = function (target) {\r\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\r\n    this.distActual += (this.distTarget - this.distActual) * 0.01;\r\n    \r\n    this.focusTarget.set(target.x, target.y + 1, target.z + this.distActual);\r\n    this.focusActual.lerp(this.focusTarget, 0.01);\r\n    \r\n    this.camera.position.copy(this.focusActual);\r\n    this.camera.lookAt(target);\r\n  };\r\n\r\n  CamControl.axisX = new THREE.Vector3(1, 0, 0);\r\n  CamControl.axisY = new THREE.Vector3(0, 1, 0);\r\n\r\n  return CamControl;\r\n}();\r\n\r\nexports.default = CamControl;\n\n//# sourceURL=webpack:///./src/Controls/CameraControl.ts?");

/***/ }),

/***/ "./src/Controls/Controls.ts":
/*!**********************************!*\
  !*** ./src/Controls/Controls.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar Joystick_1 = __webpack_require__(/*! ./Joystick */ \"./src/Controls/Joystick.ts\");\r\nvar gimbal_1 = __webpack_require__(/*! ./Gimball */ \"./src/Controls/Gimball.ts\");\r\nvar model_1 = __webpack_require__(/*! ../Model */ \"./src/Model.ts\");\r\nvar raycaster_1 = __webpack_require__(/*! ../Utility/Raycaster */ \"./src/Utility/Raycaster.ts\");\r\nvar preloader_1 = __webpack_require__(/*! ../Preloader */ \"./src/Preloader.ts\");\r\n\r\nvar Controls = function () {\r\n  function Controls() {\r\n    this.introComplete = false;\r\n    this.modeVR = false;\r\n    this.modeOrbit = false;\r\n    this.deviceTouch = undefined;\r\n    this.deviceAccel = false;\r\n    this.zoom = 1;\r\n\r\n    TweenLite.defaultEase = Power2.easeInOut;\r\n\r\n    this.pageMain = document.getElementById('pageMain');\r\n    this.model = new model_1.default(this.pageMain);\r\n    this.mouseTap = new THREE.Vector2(1000, 1000);\r\n\r\n    this.hammer = new Hammer(this.pageMain);\r\n    this.refHammerPan = this.rippleTouch.bind(this);\r\n\r\n    this.hammer.get('pan').set({\r\n      direction: Hammer.DIRECTION_ALL,\r\n      threshold: 3\r\n    });\r\n    \r\n    this.hammer.on('hammer.input', this.refHammerPan);\r\n    window.addEventListener('resize', this.onWindowResize.bind(this), false);\r\n    \r\n    this.accelTestReference = this.acceleromTest.bind(this);\r\n    window.addEventListener('deviceorientation', this.accelTestReference);\r\n    \r\n    this.ray = new raycaster_1.default(this.model.monoc.camera);\r\n    this.preload();\r\n  }\r\n\r\n  Controls.prototype.preload = function () {\r\n    var manifesto = [\r\n      {\r\n        name: 'envReflection',\r\n        type: 'cubetexture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'envSkybox',\r\n        type: 'cubetexture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'flareHead',\r\n        type: 'texture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'flareTurn',\r\n        type: 'texture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'lightTurn',\r\n        type: 'texture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'lightStop',\r\n        type: 'texture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'lightReverse',\r\n        type: 'texture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'vrBodyCompiled',\r\n        type: 'mesh',\r\n        ext: 'json'\r\n      },\r\n      {\r\n        name: 'vrWheelBrakes',\r\n        type: 'mesh',\r\n        ext: 'json'\r\n      },\r\n      {\r\n        name: 'thread',\r\n        type: 'texture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'shadow',\r\n        type: 'texture',\r\n        ext: 'jpg'\r\n      },\r\n      {\r\n        name: 'icoBtns',\r\n        type: 'texture',\r\n        ext: 'png'\r\n      },\r\n      {\r\n        name: 'icoCtrls',\r\n        type: 'texture',\r\n        ext: 'png'\r\n      }\r\n    ];\r\n\r\n    var path = '';\r\n    this.preloader = new preloader_1.Preloader(path, manifesto, this);\r\n\r\n    window['preloader'] = this.preloader;\r\n\r\n    this.preloader.start();\r\n    this.model.introPreloading();\r\n  };\r\n\r\n  Controls.prototype.preloadComplete = function (_cargo) {\r\n    this.model.introPreloaded(_cargo);\r\n    this.introComplete = true;\r\n\r\n    this.refHammerTap = this.introAnimation.bind(this);\r\n    this.hammer.on('tap', this.refHammerTap);\r\n  };\r\n\r\n  Controls.prototype.introAnimation = function (evt) {\r\n    if (typeof this.deviceTouch === 'undefined') {\r\n      this.hammerCheckTouch(evt);\r\n    }\r\n\r\n    this.hammer.off('tap', this.refHammerTap);\r\n    this.hammer.off('hammer.input', this.refHammerPan);\r\n\r\n    this.model.introStart();\r\n    this.preloader.remove();\r\n\r\n    TweenLite.delayedCall(3, this.initControls.bind(this));\r\n  };\r\n\r\n  Controls.prototype.initControls = function (evt) {\r\n    this.joystick = new Joystick_1.default();\r\n    this.gimbal = new gimbal_1.default();\r\n\r\n    this.initKeyboard();\r\n    this.initButtons();\r\n    this.initHammer();\r\n    \r\n    this.pageMain.addEventListener('wheel', this.gestureWheel.bind(this));\r\n    \r\n    window.addEventListener('deviceorientation', this.accelerometerMove.bind(this));\r\n    window.addEventListener('orientationchange', this.onDeviceReorientation.bind(this));\r\n    \r\n    this.onDeviceReorientation();\r\n\r\n    this.mobHUDTilt = document.getElementById('mobileHUDTilt');\r\n    this.mobHUDTouch = document.getElementById('mobileHUDTouch');\r\n\r\n    if (this.deviceTouch === false) {\r\n      var ctrls = document.getElementsByClassName('ctrls');\r\n\r\n      for (var i = 0; i < ctrls.length; i++) {\r\n        ctrls[i].style.opacity = '1';\r\n      }\r\n    } else {\r\n      this.showHUD();\r\n    }\r\n  };\r\n\r\n  Controls.prototype.showHUD = function () {\r\n    this.mobHUDTilt.style.opacity = '1';\r\n    this.mobHUDTouch.style.opacity = '1';\r\n\r\n    TweenLite.delayedCall(3, this.hideHUD.bind(this));\r\n  };\r\n\r\n  Controls.prototype.hideHUD = function () {\r\n    this.mobHUDTilt.style.opacity = '0';\r\n    this.mobHUDTouch.style.opacity = '0';\r\n  };\r\n\r\n  Controls.prototype.rippleTouch = function (evt) {\r\n    if (evt.isFinal === false) {\r\n      this.raycast(evt);\r\n    }\r\n  };\r\n\r\n  Controls.prototype.hammerCheckTouch = function (evt) {\r\n    switch (evt.pointerType) {\r\n\r\n      case 'mouse':\r\n        this.deviceTouch = false;\r\n        break;\r\n\r\n      case 'touch':\r\n      default:\r\n        this.deviceTouch = true;\r\n        break;\r\n    }\r\n  };\r\n\r\n  Controls.prototype.initHammer = function () {\r\n    if (this.deviceTouch) {\r\n      this.hammer.get('pinch').set({ enable: true });\r\n      this.hammer.on('hammer.input', this.hammerInput.bind(this));\r\n      this.hammer.on('pinchstart', this.hammerPinchStart.bind(this));\r\n      this.hammer.on('pinch', this.hammerPinch.bind(this));\r\n    } else {\r\n      this.hammer.get('pan').set({\r\n        direction: Hammer.DIRECTION_ALL,\r\n        threshold: 1\r\n      });\r\n\r\n      this.hammer.on('pan', this.hammerPan.bind(this));\r\n    }\r\n  };\r\n\r\n  Controls.prototype.hammerPan = function (event) {\r\n    this.model.cam.orbitBy(event.velocityX, event.velocityY);\r\n  };\r\n\r\n  Controls.prototype.hammerPinchStart = function (event) {\r\n    this.zoom = this.model.cam.distTarget;\r\n  };\r\n\r\n  Controls.prototype.hammerPinch = function (event) {\r\n    this.model.cam.distTarget = this.zoom / event.scale;\r\n  };\r\n\r\n  Controls.prototype.hammerInput = function (event) {\r\n    if (this.modeVR === false) {\r\n      this.model.props.onJoystickMove(this.joystick.gestureInput(event));\r\n    }\r\n  };\r\n\r\n  Controls.prototype.raycast = function (event) {\r\n    this.mouseTap.x = event.pointers[0].clientX / this.model.vpW * 2 - 1;\r\n    this.mouseTap.y = event.pointers[0].clientY / this.model.vpH * -2 + 1;\r\n    \r\n    var pos = this.ray.rayCast(this.mouseTap);\r\n\r\n    if (typeof pos !== 'boolean') {\r\n      this.model.grid.moveRippleOrigin(pos.x, pos.z);\r\n    }\r\n  };\r\n\r\n  Controls.prototype.initKeyboard = function () {\r\n    window.addEventListener('keydown', this.model.props.onKeyDown.bind(this.model.props), false);\r\n    window.addEventListener('keyup', this.model.props.onKeyUp.bind(this.model.props), false);\r\n  };\r\n\r\n  Controls.prototype.initButtons = function () {\r\n    this.btnVR = document.getElementById('btnVR');\r\n    this.btnVRO = document.getElementById('btnVRO');\r\n    this.btnVREsc = document.getElementById('btnVREsc');\r\n    this.btnEnterF = document.getElementById('btnEnterFull');\r\n    this.btnExitF = document.getElementById('btnExitFull');\r\n\r\n    if (this.deviceAccel) {\r\n      this.modeOrbit = true;\r\n\r\n      this.btnVR.style.display = 'block';\r\n      this.btnVRO.style.display = 'block';\r\n\r\n      this.btnVR.addEventListener('click', this.enterVRMode.bind(this));\r\n      this.btnVRO.addEventListener('click', this.enterVROrbitMode.bind(this));\r\n     \r\n      this.btnVREsc.addEventListener('click', this.exitVRMode.bind(this));\r\n      this.noSleep = new NoSleep();\r\n    }\r\n\r\n    if (!/(iPad|iPhone|iPod)/g.test(navigator.userAgent)) {\r\n      this.btnEnterF.style.display = 'block';\r\n\r\n      this.btnExitF.addEventListener('click', this.fullScreenExit.bind(this));\r\n      this.btnEnterF.addEventListener('click', this.fullScreenEnter.bind(this));\r\n      \r\n      document.addEventListener('fullscreenchange', this.fullScreenChanged.bind(this), false);\r\n      document.addEventListener('MSFullscreenChange', this.fullScreenChanged.bind(this), false);\r\n      document.addEventListener('mozfullscreenchange', this.fullScreenChanged.bind(this), false);\r\n      document.addEventListener('webkitfullscreenchange', this.fullScreenChanged.bind(this), false);\r\n    }\r\n  };\r\n\r\n  Controls.prototype.enterVRMode = function () {\r\n    if (this.modeVR == true) {\r\n      return;\r\n    }\r\n\r\n    this.modeVR = true;\r\n    this.modeOrbit = false;\r\n\r\n    this.hideHUD();\r\n    this.changedVRMode();\r\n\r\n    this.noSleep.enable();\r\n  };\r\n\r\n  Controls.prototype.enterVROrbitMode = function () {\r\n    if (this.modeVR == true) {\r\n      return;\r\n    }\r\n\r\n    this.modeVR = true;\r\n    this.modeOrbit = true;\r\n\r\n    this.hideHUD();\r\n    this.changedVRMode();\r\n\r\n    this.noSleep.enable();\r\n  };\r\n\r\n  Controls.prototype.exitVRMode = function () {\r\n    if (this.modeVR == false) {\r\n      return;\r\n    }\r\n\r\n    this.modeVR = false;\r\n    this.modeOrbit = true;\r\n    this.model.props.joyVec.set(0, 0);\r\n\r\n    this.changedVRMode();\r\n    this.showHUD();\r\n\r\n    this.noSleep.disable();\r\n  };\r\n\r\n  Controls.prototype.changedVRMode = function () {\r\n    this.btnVR.style.display = this.modeVR ? 'none' : 'block';\r\n    this.btnVRO.style.display = this.modeVR ? 'none' : 'block';\r\n    this.btnVREsc.style.display = this.modeVR ? 'block' : 'none';\r\n\r\n    this.model.toggleStereo(this.modeVR, this.modeOrbit);\r\n  };\r\n\r\n  Controls.prototype.fullScreenChanged = function () {\r\n    if (document.fullscreen || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement == false) {\r\n      this.btnExitF.style.display = 'block';\r\n      this.btnEnterF.style.display = 'none';\r\n    } else {\r\n      this.btnExitF.style.display = 'none';\r\n      this.btnEnterF.style.display = 'block';\r\n    }\r\n  };\r\n\r\n  Controls.prototype.fullScreenEnter = function () {\r\n    if(this.pageMain.webkitRequestFullscreen) \r\n      this.pageMain.webkitRequestFullscreen();\r\n    else if (this.pageMain.mozRequestFullScreen) \r\n      this.pageMain.mozRequestFullScreen();\r\n    else \r\n      this.pageMain.requestFullscreen();\r\n    \r\n  };\r\n\r\n  Controls.prototype.fullScreenExit = function () {\r\n    if (document.webkitExitFullscreen)\r\n      document.webkitExitFullscreen();\r\n    else if (document.mozCancelFullScreen)\r\n      document.mozCancelFullScreen();\r\n    else\r\n      document.exitFullscreen();\r\n  };\r\n\r\n  Controls.prototype.acceleromTest = function (event) {\r\n    if (typeof event.alpha != 'undefined' && typeof event.beta != 'undefined' && typeof event.gamma != 'undefined') {\r\n      this.deviceAccel = true;\r\n    }\r\n\r\n    window.removeEventListener('deviceorientation', this.accelTestReference);\r\n  };\r\n\r\n  Controls.prototype.accelerometerMove = function (event) {\r\n    if (this.modeOrbit === true) {\r\n      this.model.cam.onGyroMove(event.alpha, event.beta, event.gamma);\r\n    } else {\r\n      this.gimbal.onGyroMove(event.alpha, event.beta, event.gamma);\r\n      \r\n      if (Math.abs(this.gimbal.roll) > 5) {\r\n        this.model.props.joyVec.x = THREE.Math.clamp(-this.gimbal.roll / 25, -1, 1);\r\n      } else {\r\n        this.model.props.joyVec.x = 0;\r\n      }\r\n\r\n      this.model.props.joyVec.y = THREE.Math.clamp((this.gimbal.attack + 20) / 30, -1, 1);\r\n    }\r\n  };\r\n\r\n  Controls.prototype.gestureWheel = function (event) {\r\n    switch (event.deltaMode) {\r\n      case 0:\r\n        this.model.cam.dolly(event.deltaY * 0.2);\r\n        break;\r\n        \r\n      case 1:\r\n        this.model.cam.dolly(event.deltaY * 20);\r\n        break;\r\n\r\n      case 2:\r\n        this.model.cam.dolly(event.deltaY * 40);\r\n        break;\r\n    }\r\n  };\r\n\r\n  Controls.prototype.onDeviceReorientation = function () {\r\n    this.model.deviceAngle = 0;\r\n\r\n    if (window.orientation) {\r\n      this.model.deviceAngle = parseInt(window.orientation.toString(), 10) * -1;\r\n    }\r\n\r\n    this.model.cam.onDeviceReorientation(this.model.deviceAngle);\r\n    this.gimbal.onDeviceReorientation(this.model.deviceAngle);\r\n  };\r\n\r\n  Controls.prototype.onWindowResize = function () {\r\n    this.model.onWindowResize();\r\n  };\r\n\r\n  Controls.prototype.update = function (t) {\r\n    if (this.introComplete === false)\r\n      this.model.updateIntro(t);\r\n    else\r\n      this.model.update(t, this.modeVR);\r\n    \r\n  };\r\n\r\n  return Controls;\r\n}();\r\n\r\nexports.default = Controls;\n\n//# sourceURL=webpack:///./src/Controls/Controls.ts?");

/***/ }),

/***/ "./src/Controls/Gimball.ts":
/*!*********************************!*\
  !*** ./src/Controls/Gimball.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Gimbal = function () {\r\n  function Gimbal() {\r\n    this.RAD = Math.PI / 180;\r\n    this.DEG = 180 / Math.PI;\r\n\r\n    this.quaternion = new THREE.Quaternion();\r\n\r\n    this.xVec = new THREE.Vector3(1, 0, 0);\r\n    this.yVec = new THREE.Vector3(0, 1, 0);\r\n    this.zVec = new THREE.Vector3(0, 0, 1);\r\n\r\n    this.deviceAngle = 0;\r\n\r\n    this.object = new THREE.Object3D();\r\n    this.angles = new THREE.Euler();\r\n    this.eulerOrigin = new THREE.Euler();\r\n\r\n    if (typeof window.orientation !== 'undefined') {\r\n      this.eulerOrigin.set(90 * this.RAD, 180 * this.RAD, (180 + parseInt(window.orientation.toString(), 10)) * this.RAD);\r\n    }\r\n  }\r\n\r\n  Gimbal.prototype.onGyroMove = function (_a, _b, _g) {\r\n    this.object.setRotationFromEuler(this.eulerOrigin);\r\n\r\n    this.object.rotateZ(_a * this.RAD);\r\n    this.object.rotateX(_b * this.RAD);\r\n    this.object.rotateY(_g * this.RAD);\r\n\r\n    this.object.rotation.z += this.deviceAngle;\r\n    this.quaternion.copy(this.object.quaternion.inverse());\r\n\r\n    this.yVec.set(0, 1, 0);\r\n    this.yVec.applyQuaternion(this.quaternion);\r\n    this.zVec.set(0, 0, 1);\r\n    this.zVec.applyQuaternion(this.quaternion);\r\n\r\n    this.heading = Math.atan2(this.zVec.x, this.zVec.z) * this.DEG;\r\n    \r\n    this.attack = Math.atan2(-this.yVec.z, this.yVec.y) * this.DEG;\r\n    this.attack = Math.min(Math.max(this.attack, -90), 90);\r\n    \r\n    this.roll = Math.atan2(-this.yVec.x, this.yVec.y) * this.DEG;\r\n  };\r\n\r\n  Gimbal.prototype.onDeviceReorientation = function (_orientation) {\r\n    this.deviceAngle = _orientation * this.RAD;\r\n  };\r\n\r\n  return Gimbal;\r\n}();\r\n\r\nexports.default = Gimbal;\n\n//# sourceURL=webpack:///./src/Controls/Gimball.ts?");

/***/ }),

/***/ "./src/Controls/Joystick.ts":
/*!**********************************!*\
  !*** ./src/Controls/Joystick.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar Joystick = function () {\r\n  function Joystick() {\r\n    this.visible = false;\r\n    this.posStart = new THREE.Vector2();\r\n    this.posNow = new THREE.Vector2();\r\n\r\n    this.circleIn = document.getElementById('joyIn');\r\n    this.circleOut = document.getElementById('joyOut');\r\n  }\r\n\r\n  Joystick.prototype.gestureInput = function (event) {\r\n    if (event.pointers.length === 1) {\r\n      switch (event.eventType) {\r\n        case 1:\r\n          this.touchStart(event.pointers[0].clientX, event.pointers[0].clientY);\r\n          break;\r\n\r\n        case 2:\r\n          this.touchMove(event.pointers[0].clientX, event.pointers[0].clientY);\r\n          break;\r\n\r\n        case 4:\r\n          this.touchEnd();\r\n          break;\r\n      }\r\n    } else {\r\n      this.touchEnd();\r\n    }\r\n\r\n    return this.posNow;\r\n  };\r\n\r\n  Joystick.prototype.touchStart = function (_pX, _pY) {\r\n    this.visible = true;\r\n\r\n    this.circleIn.style.display = 'block';\r\n    this.circleIn.style.top = _pY + 'px';\r\n    this.circleIn.style.left = _pX + 'px';\r\n    \r\n    this.circleOut.style.display = 'block';\r\n    this.circleOut.style.top = _pY + 'px';\r\n    this.circleOut.style.left = _pX + 'px';\r\n\r\n    this.posStart.set(_pX, _pY);\r\n  };\r\n\r\n  Joystick.prototype.touchMove = function (_pX, _pY) {\r\n    if (this.visible === false) {\r\n      this.touchStart(_pX, _pY);\r\n    }\r\n\r\n    this.posNow.set(_pX - this.posStart.x, _pY - this.posStart.y);\r\n    this.posNow.clampLength(0, 40);\r\n    this.circleIn.style.transform = 'translate(' + (this.posNow.x - 34) + 'px, ' + (this.posNow.y - 34) + 'px)';\r\n  };\r\n\r\n  Joystick.prototype.touchEnd = function () {\r\n    this.circleIn.style.display = 'none';\r\n    this.circleOut.style.display = 'none';\r\n    this.circleIn.style.transform = 'translate(-34px, -34px)';\r\n    this.posNow.set(0, 0);\r\n    this.visible = false;\r\n  };\r\n\r\n  return Joystick;\r\n}();\r\n\r\nexports.default = Joystick;\n\n//# sourceURL=webpack:///./src/Controls/Joystick.ts?");

/***/ }),

/***/ "./src/Grid.ts":
/*!*********************!*\
  !*** ./src/Grid.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar rippleGen_1 = __webpack_require__(/*! ./Utility/RippleGenerator */ \"./src/Utility/RippleGenerator.ts\");\r\nvar utils_1 = __webpack_require__(/*! ./Utility/Utils */ \"./src/Utility/Utils.ts\");\r\nvar fragShader = __webpack_require__(/*! ./Shaders/FragmentShader */ \"./src/Shaders/FragmentShader.ts\");\r\nvar vertShader = __webpack_require__(/*! ./Shaders/VerticalShader */ \"./src/Shaders/VerticalShader.ts\");\r\n\r\nvar Grid = function () {\r\n  function Grid(_scene , _renderer ) {\r\n    this.GRID_SIZE = 32;\r\n    this.GRID_HALFSIZE = 16;\r\n    this.parent = _scene;\r\n    this.prevOrigin = new THREE.Vector2();\r\n    this.ripplePos = new THREE.Vector2();\r\n    this.rippleGen = new rippleGen_1.default(_renderer, this.ripplePos, this.GRID_SIZE);\r\n    this.generateGrid();\r\n  }\r\n\r\n  Grid.prototype.generateGrid = function () {\r\n    this.ledSprite = new THREE.TextureLoader().load('textures/ledA.png');\r\n    this.color = new THREE.Color(0xFFFFFF);\r\n\r\n    this.gridMaterial = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        led: {\r\n          value: this.ledSprite\r\n        },\r\n        heightmap: {\r\n          value: null\r\n        },\r\n        vpH: {\r\n          value: window.innerHeight\r\n        },\r\n        prog: {\r\n          value: 0\r\n        },\r\n        origin: {\r\n          value: new THREE.Vector2()\r\n        },\r\n        color: {\r\n          value: this.color\r\n        }\r\n      },\r\n      defines: {\r\n        RANGE: (this.GRID_SIZE / 2).toFixed(1),\r\n        RANGE2: this.GRID_SIZE.toFixed(1)\r\n      },\r\n      vertexShader: vertShader,\r\n      fragmentShader: fragShader,\r\n      transparent: true,\r\n      depthWrite: false\r\n    });\r\n\r\n    this.uniProgress = this.gridMaterial.uniforms['prog'];\r\n    this.uniOrigin = this.gridMaterial.uniforms['origin'];\r\n    var vertCount = Math.pow(this.GRID_SIZE, 2);\r\n    var position = new Float32Array(vertCount * 3);\r\n    var uvs = new Float32Array(vertCount * 2);\r\n    var diagonal = new Uint16Array(vertCount);\r\n    var randI = THREE.Math.randInt;\r\n    var xPos = 0;\r\n    var zPos = 0;\r\n\r\n    for (var i = 0, i3 = 0; i < vertCount; i++, i3 += 3) {\r\n      xPos = i % this.GRID_SIZE;\r\n      zPos = Math.floor(i / this.GRID_SIZE);\r\n      position[i3 + 0] = xPos - this.GRID_HALFSIZE;\r\n      position[i3 + 1] = 0;\r\n      position[i3 + 2] = zPos - this.GRID_HALFSIZE;\r\n      uvs[i * 2 + 0] = xPos / this.GRID_SIZE;\r\n      uvs[i * 2 + 1] = 1 - zPos / this.GRID_SIZE;\r\n      diagonal[i] = (xPos + zPos) % 2;\r\n    }\r\n\r\n    this.geometry = new THREE.BufferGeometry();\r\n    this.geometry.addAttribute('position', new THREE.BufferAttribute(position, 3));\r\n    this.geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\r\n    this.geometry.addAttribute('diagonal', new THREE.BufferAttribute(diagonal, 1));\r\n    this.lightGrid = new THREE.Points(this.geometry, this.gridMaterial);\r\n    this.lightGrid.frustumCulled = false;\r\n    this.parent.add(this.lightGrid);\r\n  };\r\n\r\n  Grid.prototype.moveRippleOrigin = function (_x, _y) {\r\n    this.ripplePos.set(_x, _y);\r\n  };\r\n\r\n  Grid.prototype.showWhiteGrid = function () {\r\n    TweenLite.to(this.uniProgress, 2, {\r\n      value: 1,\r\n      easing: Power2.easeInOut,\r\n      onStart: function () {}.bind(this)\r\n    });\r\n  };\r\n\r\n  Grid.prototype.goToBlackGrid = function () {\r\n    TweenLite.to(this.color, 1, {\r\n      r: 0,\r\n      g: 0,\r\n      b: 0,\r\n      easing: Power2.easeInOut\r\n    });\r\n\r\n    TweenLite.to(this.uniProgress, 1, {\r\n      value: 0,\r\n      easing: Power2.easeInOut\r\n    });\r\n  };\r\n\r\n  Grid.prototype.update = function (_props) {\r\n    if (typeof _props != 'undefined' && _props.speed > 0) {\r\n      this.rippleGen.newRippleImpact(_props.speed / 64);\r\n      this.moveRippleOrigin(utils_1.mod(_props.pos.x + this.GRID_HALFSIZE, this.GRID_SIZE) - this.GRID_HALFSIZE, utils_1.mod(_props.pos.y + this.GRID_HALFSIZE, this.GRID_SIZE) - this.GRID_HALFSIZE);\r\n      this.uniOrigin.value = _props.pos;\r\n    }\r\n\r\n    this.gridMaterial.uniforms['heightmap'].value = this.rippleGen.update();\r\n    this.moveRippleOrigin(1000, 1000);\r\n  };\r\n\r\n  Grid.prototype.onWindowResize = function (vpW, vpH, pixelRatio) {\r\n    this.gridMaterial.uniforms['vpH'].value = vpH * pixelRatio;\r\n  };\r\n\r\n  return Grid;\r\n}();\r\n\r\nexports.default = Grid;\n\n//# sourceURL=webpack:///./src/Grid.ts?");

/***/ }),

/***/ "./src/Init.ts":
/*!*********************!*\
  !*** ./src/Init.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Controls_1 = __webpack_require__(/*! ./Controls/Controls */ \"./src/Controls/Controls.ts\");\r\nvar control;\r\n\r\nfunction noWebGL() {\r\n  document.getElementById('preloader').className = 'visible';\r\n  document.getElementById('preLogo').style.display = 'block';\r\n  document.getElementById('preButton').style.display = 'block';\r\n  document.getElementById('preDetail').innerHTML = translations['BROWSER_BAD'];\r\n}\r\n\r\nfunction initApp() {\r\n  control = new Controls_1.default();\r\n  render(0);\r\n}\r\n\r\nfunction render(t) {\r\n  control.update(t * 0.001);\r\n  requestAnimationFrame(render);\r\n}\r\n\r\nfunction browserCheck() {\r\n  return !navigator.userAgent.match(/UCBrowser/);\r\n}\r\n\r\nfunction detectWebGL() {\r\n  try {\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n    window['EXT_STLOD_SUPPORT'] = context.getExtension('EXT_shader_texture_lod') ? true : false;\r\n    return !!(window.WebGLRenderingContext && context);\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\nif (detectWebGL() && browserCheck()) {\r\n  initApp();\r\n} else {\r\n  noWebGL();\r\n}\n\n//# sourceURL=webpack:///./src/Init.ts?");

/***/ }),

/***/ "./src/Model.ts":
/*!**********************!*\
  !*** ./src/Model.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar camera_1 = __webpack_require__(/*! ./Controls/CameraControl */ \"./src/Controls/CameraControl.ts\");\r\nvar binocs_1 = __webpack_require__(/*! ./Utility/Binocs */ \"./src/Utility/Binocs.ts\");\r\nvar CarBody_1 = __webpack_require__(/*! ./Car/CarBody */ \"./src/Car/CarBody.ts\");\r\nvar CarProps_1 = __webpack_require__(/*! ./Car/CarProps */ \"./src/Car/CarProps.ts\");\r\nvar grid_1 = __webpack_require__(/*! ./Grid */ \"./src/Grid.ts\");\r\nvar Utils = __webpack_require__(/*! ./Utility/Utils */ \"./src/Utility/Utils.ts\");\r\n\r\nvar Model = function () {\r\n  function Model(_main) {\r\n    this.deviceAngle = 0;\r\n    this.pageMain = _main;\r\n    this.vpW = this.pageMain.clientWidth;\r\n    this.vpH = this.pageMain.clientHeight;\r\n    this.props = new CarProps_1.CarProps();\r\n    this.camTarget = new THREE.Vector3(0, 1, 1.56);\r\n    this.scene = new THREE.Scene();\r\n    this.renderer = new THREE.WebGLRenderer({\r\n      antialias: true\r\n    });\r\n    \r\n    this.renderer.setPixelRatio(1);\r\n    this.renderer.setSize(this.vpW, this.vpH);\r\n    this.renderer.setClearColor(0x393533);\r\n    this.renderer.autoClear = false;\r\n    this.camOptions = {\r\n      distance: 7,\r\n      focusPos: this.camTarget,\r\n      distRange: {\r\n        max: 40,\r\n        min: 4\r\n      },\r\n      rotation: new THREE.Vector3(45, 0, 0),\r\n      rotRange: {\r\n        yMin: -1\r\n      },\r\n      eyeSeparation: 0.3\r\n    };\r\n\r\n    this.monoc = new camera_1.default(this.camOptions);\r\n    this.cam = this.monoc;\r\n    this.grid = new grid_1.default(this.scene, this.renderer);\r\n    this.pageMain.appendChild(this.renderer.domElement);\r\n    this.addSceneLights();\r\n  }\r\n\r\n  Model.prototype.introPreloading = function () {\r\n    this.grid.showWhiteGrid();\r\n\r\n    TweenLite.to(this.cam, 1, {\r\n      distTarget: 30\r\n    });\r\n\r\n    TweenLite.to(this.cam.rotTarget, 1, {\r\n      x: 0,\r\n      y: 90\r\n    });\r\n  };\r\n  \r\n  Model.prototype.introPreloaded = function (_cargo) {\r\n    this.car = new CarBody_1.default(this.scene, _cargo);\r\n    this.skyRadiance = _cargo['envSkybox'];\r\n    this.skyRadiance.format = THREE.RGBFormat;\r\n    this.scene.background = this.skyRadiance;\r\n  };\r\n\r\n  Model.prototype.introStart = function () {\r\n    this.grid.goToBlackGrid();\r\n\r\n    TweenLite.to(this.cam.rotTarget, 1, {\r\n      x: -20,\r\n      y: 0\r\n    });\r\n\r\n    TweenLite.to(this.cam, 1, {\r\n      distTarget: 10,\r\n      distActual: 10\r\n    });\r\n\r\n    TweenLite.to(this.spotLight, 3, {\r\n      intensity: 1\r\n    });\r\n\r\n    TweenLite.to(this.props, 3, {\r\n      speed: 12\r\n    });\r\n  };\r\n\r\n  Model.prototype.addSceneLights = function () {\r\n    this.ambLight = new THREE.AmbientLight(0xFFFFFF, 0);\r\n    this.spotLight = new THREE.DirectionalLight(0xFFFFFF, 0);\r\n    \r\n    this.spotLight.position.set(0, 2, 0);\r\n\r\n    this.scene.add(this.spotLight);\r\n    this.scene.add(this.ambLight);\r\n  };\r\n  \r\n  Model.prototype.toggleStereo = function (_stereo, _orbit) {\r\n    if (_stereo) {\r\n      if (typeof this.binocs === 'undefined') {\r\n        this.binocs = new binocs_1.default(this.camOptions);\r\n        this.binocs.distTarget = 10;\r\n      }\r\n\r\n      this.cam = this.binocs;\r\n      this.scene.add(this.binocs.binoculars);\r\n      \r\n      this.renderer.setScissorTest(true);\r\n      this.renderer.setPixelRatio(window.devicePixelRatio >= 2 ? 2 : 1);\r\n      \r\n      if (_orbit === false) {\r\n        this.binocs.setRotation(Utils.mod(this.monoc.rotActual.x, 360), this.monoc.rotActual.y, 0);\r\n        this.binocs.rotTarget.x = 180 - Math.atan2(this.props.velocity.x, this.props.velocity.y) * (180 / Math.PI);\r\n        this.binocs.rotTarget.y = 10;\r\n      }\r\n    } else {\r\n      this.cam = this.monoc;\r\n      this.scene.remove(this.binocs.binoculars);\r\n\r\n      this.renderer.setViewport(0, 0, this.vpW, this.vpH);\r\n      this.renderer.setScissorTest(false);\r\n      this.renderer.setPixelRatio(1);\r\n    }\r\n    \r\n    this.grid.onWindowResize(this.vpW, this.vpH, this.renderer.getPixelRatio());\r\n    this.cam.onDeviceReorientation(this.deviceAngle);\r\n\r\n    this.onWindowResize();\r\n  };\r\n\r\n  Model.prototype.onWindowResize = function () {\r\n    this.vpW = this.pageMain.clientWidth;\r\n    this.vpH = this.pageMain.clientHeight;\r\n\r\n    this.grid.onWindowResize(this.vpW, this.vpH, this.renderer.getPixelRatio());\r\n    this.car.onWindowResize(this.vpH);\r\n    this.renderer.setSize(this.vpW, this.vpH);\r\n    this.monoc.onWindowResize(this.vpW, this.vpH);\r\n\r\n    if (typeof this.binocs !== 'undefined') {\r\n      this.binocs.onWindowResize(this.vpW, this.vpH);\r\n    }\r\n  };\r\n\r\n  Model.prototype.updateIntro = function (time) {\r\n    this.renderer.clear();\r\n    this.grid.update();\r\n    this.cam.update();\r\n    this.renderer.render(this.scene, this.monoc.camera);\r\n  };\r\n\r\n  Model.prototype.update = function (time, _stereo) {\r\n    if (this.props.update(time) === false) {\r\n      return;\r\n    }\r\n\r\n    this.renderer.clear();\r\n\r\n    this.car.update(this.props);\r\n    this.grid.update(this.props);\r\n    \r\n    this.camTarget.copy(this.car.carChassis.getWorldPosition());\r\n    \r\n    this.cam.setFocusPos(this.camTarget.x, 1, this.camTarget.z);\r\n    this.cam.update();\r\n\r\n    if (_stereo) {\r\n      this.spotLight.position.copy(this.binocs.binoculars.position).normalize();\r\n      this.spotLight.position.y = 1;\r\n      this.binocs.renderStereo(this.renderer, this.scene);\r\n    } else {\r\n      this.spotLight.position.copy(this.monoc.camera.position).normalize();\r\n      this.spotLight.position.y = 1;\r\n      this.renderer.render(this.scene, this.monoc.camera, null, false);\r\n    }\r\n  };\r\n\r\n  return Model;\r\n}();\r\n\r\nexports.default = Model;\n\n//# sourceURL=webpack:///./src/Model.ts?");

/***/ }),

/***/ "./src/Preloader.ts":
/*!**************************!*\
  !*** ./src/Preloader.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Preloader = function () {\r\n  function Preloader(_path, _manifesto, _parent) {\r\n    this.path = _path;\r\n    this.manifesto = _manifesto;\r\n    this.parent = _parent;\r\n    this.assetCount = 0;\r\n    this.assetTotal = _manifesto.length;\r\n    this.loaderText = new THREE.TextureLoader();\r\n    this.loaderMesh = new THREE.ObjectLoader();\r\n    this.loaderCube = new THREE.CubeTextureLoader();\r\n    this.cargo = {};\r\n    this.container = document.getElementById('preloader');\r\n    this.progBar = document.getElementById('preProg');\r\n    this.detailBox = document.getElementById('preDetail');\r\n  }\r\n  Preloader.prototype.start = function () {\r\n    this.container.className = 'visible';\r\n    this.detailBox.innerHTML = translations['LOADING_ASSETS'];\r\n    var ext;\r\n    var _loop_1 = function (i) {\r\n      ext = '.' + this_1.manifesto[i].ext;\r\n      switch (this_1.manifesto[i].type) {\r\n        case 'texture':\r\n          this_1.loaderText.load(this_1.path + 'textures/' + this_1.manifesto[i].name + ext, function (_obj) {\r\n            this.assetAquired(_obj, this.manifesto[i].name);\r\n          }.bind(this_1), undefined, function (_err) {\r\n            this.assetFailed(_err, this.manifesto[i].name);\r\n          }.bind(this_1));\r\n          break;\r\n        case 'mesh':\r\n          this_1.loaderMesh.load(this_1.path + 'meshes/' + this_1.manifesto[i].name + '.json', function (_obj) {\r\n            this.assetAquired(_obj, this.manifesto[i].name);\r\n          }.bind(this_1), undefined, function (_err) {\r\n            this.assetFailed(_err, this.manifesto[i].name);\r\n          }.bind(this_1));\r\n          break;\r\n        case 'cubetexture':\r\n          this_1.loaderCube.setPath(this_1.path + 'textures/' + this_1.manifesto[i].name + '/');\r\n          this_1.loaderCube.load([\r\n            'xp' + ext,\r\n            'xn' + ext,\r\n            'yp' + ext,\r\n            'yn' + ext,\r\n            'zp' + ext,\r\n            'zn' + ext\r\n          ], function (_obj) {\r\n            this.assetAquired(_obj, this.manifesto[i].name);\r\n          }.bind(this_1), undefined, function (_err) {\r\n            this.assetFailed(_err, this.manifesto[i].name);\r\n          }.bind(this_1));\r\n          break;\r\n      }\r\n    };\r\n    var this_1 = this;\r\n    for (var i = 0; i < this.assetTotal; i++) {\r\n      _loop_1(i);\r\n    }\r\n  };\r\n  Preloader.prototype.assetAquired = function (_obj, _name) {\r\n    this.cargo[_name] = _obj;\r\n    this.assetCount++;\r\n    this.pct = this.assetCount / this.assetTotal;\r\n    this.progBar.style.width = this.pct * 100 + '%';\r\n    if (this.assetCount == this.assetTotal) {\r\n      this.complete();\r\n    }\r\n  };\r\n  Preloader.prototype.assetFailed = function (_err, _name) {\r\n    this.assetCount++;\r\n    this.pct = this.assetCount / this.assetTotal;\r\n    if (this.assetCount == this.assetTotal) {\r\n      this.complete();\r\n    }\r\n  };\r\n  Preloader.prototype.complete = function () {\r\n    this.detailBox.innerHTML = translations['BUILDING_CAR'];\r\n    TweenLite.delayedCall(0.5, function () {\r\n      this.parent.preloadComplete(this.cargo);\r\n      this.detailBox.innerHTML = translations['TAP_TO_BEGIN'];\r\n    }.bind(this));\r\n  };\r\n  Preloader.prototype.remove = function () {\r\n    this.container.className = '';\r\n  };\r\n  return Preloader;\r\n}();\r\nexports.Preloader = Preloader;\n\n//# sourceURL=webpack:///./src/Preloader.ts?");

/***/ }),

/***/ "./src/Shaders/FlareFS.ts":
/*!********************************!*\
  !*** ./src/Shaders/FlareFS.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform vec3 color;\\nuniform sampler2D texture;\\n\\nvarying float opacity;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\t// Additive\\n    gl_FragColor = texture2D( texture, gl_PointCoord);\\n    gl_FragColor.a = normFloat(opacity, 0.01, 0.1);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/FlareFS.ts?");

/***/ }),

/***/ "./src/Shaders/FlareVS.ts":
/*!********************************!*\
  !*** ./src/Shaders/FlareVS.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define PI 3.1415926\\n\\nuniform float vpH;\\nuniform float size;\\nuniform float brightness;\\nvarying float opacity;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n    vec4 realPos = modelMatrix * vec4(position, 1.0);\\n    vec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n    vec3 lightVector = normalize(cameraPosition - realPos.xyz);\\n    opacity = dot(realNorm, lightVector);\\n    opacity = normFloat(opacity, 0.5, 1.0) * brightness;\\n\\n    vec4 mvPosition = viewMatrix * realPos;\\n    gl_Position = projectionMatrix * mvPosition;\\n    gl_PointSize = max((vpH * size / -mvPosition.z) * opacity, 0.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/FlareVS.ts?");

/***/ }),

/***/ "./src/Shaders/FragmentShader.ts":
/*!***************************************!*\
  !*** ./src/Shaders/FragmentShader.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform sampler2D led;\\nuniform vec3 color;\\n\\nvarying float opacity;\\nvarying float diag;\\n\\nvoid main() {\\n\\t// Multiplicative\\n    // gl_FragColor = -texture2D( led, vec2(abs(diag - gl_PointCoord.x), gl_PointCoord.y )) * opacity;\\n    // gl_FragColor += 1.0;\\n\\n\\t// Additive\\n    gl_FragColor = texture2D( led, vec2(abs(diag - gl_PointCoord.x), gl_PointCoord.y )) * vec4(color, opacity);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/FragmentShader.ts?");

/***/ }),

/***/ "./src/Shaders/HMFragment.ts":
/*!***********************************!*\
  !*** ./src/Shaders/HMFragment.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'precision highp float;\\nprecision highp int;\\n\\n#include <common>\\n\\nuniform vec2 ripplePos;\\nuniform float rippleSize;\\nuniform float viscosity;\\nuniform float rippleImpact;\\nuniform sampler2D heightmap;\\n\\n#define deltaTime ( 1.0 / 60.0 )\\n#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 1.0 )\\n\\nvoid main()\\t{\\n\\n\\tvec2 cellSize = 1.0 / resolution.xy;\\n\\n\\tvec2 uv = gl_FragCoord.xy * cellSize;\\n\\n\\t// heightmapValue.x == height\\n\\t// heightmapValue.y == velocity\\n\\t// heightmapValue.z, heightmapValue.w not used\\n\\tvec4 heightmapValue = texture2D( heightmap, uv );\\n\\n\\t// Get neighbours\\n\\tfloat north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) ).r;\\n\\tfloat south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) ).r;\\n\\tfloat east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) ).r;\\n\\tfloat west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) ).r;\\n\\n\\tfloat sump = north + south + east + west - 4.0 * heightmapValue.x;\\n\\n\\tfloat accel = sump * GRAVITY_CONSTANT;\\n\\n\\t// Dynamics\\n\\theightmapValue.y += accel;\\n\\theightmapValue.x += heightmapValue.y * deltaTime;\\n\\n\\t// Viscosity\\n\\theightmapValue.x += sump * viscosity;\\n\\n\\t// Mouse influence\\n\\tfloat mousePhase = clamp( \\n\\t\\tlength(( uv - vec2( 0.5 ) ) * BOUNDS - vec2( ripplePos.x, - ripplePos.y ) ) * PI / rippleSize, \\n\\t\\t0.0, \\n\\t\\tPI\\n\\t);\\n\\theightmapValue.x += (cos( mousePhase ) + 1.0) * rippleImpact;\\n\\n\\t// Bring X back to 0 over time to prevent endless growth\\n\\theightmapValue.x *= 0.998;\\n\\n\\t// gl_FragColor = vec4(heightmapValue.x, 0.0, 0.0, 1.0);\\n\\tgl_FragColor = heightmapValue;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/HMFragment.ts?");

/***/ }),

/***/ "./src/Shaders/HeadGridVS.ts":
/*!***********************************!*\
  !*** ./src/Shaders/HeadGridVS.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'float normFloat(float n, float minVal, float maxVal){\\n\\treturn max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\n// Returns 1 if type matches val, 0 if not\\nfloat checkType(float type, float val){\\n\\treturn step(val - 0.1, type) * step(type, val + 0.1);\\n}\\n\\nuniform vec3 lightsT;\\nuniform vec3 lightsO;\\nattribute float type;\\nvarying float wht;\\nvarying float amb;\\n\\n// z-up position because Blender is weird like that\\nvoid main() {\\n\\tvec2 posXY = vec2(position.y - 2299.0, position.z - 1355.0);\\n\\tfloat distOrigin = distance(posXY, vec2(0.0));   // FF Logo\\n\\n\\t// 0: Daytime running lights\\n\\twht = checkType(type, 0.0);\\n\\t\\n\\t// 1: nightlights\\n\\twht += checkType(type, 1.0) * lightsO.y;\\n\\t\\n\\t// 2: high beams\\n\\twht += checkType(type, 2.0) * lightsO.z;\\n\\t\\n\\t// 3: right turn signal\\n\\twht += checkType(type, 3.0) * (1.0 - lightsT.x);\\n\\tamb = checkType(type, 3.0) * lightsT.z;\\n\\t\\n\\t// 4: left turn signal\\n\\twht += checkType(type, 4.0) * (1.0 + lightsT.x);\\n\\tamb += checkType(type, 4.0) * lightsT.y;\\n\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/HeadGridVS.ts?");

/***/ }),

/***/ "./src/Shaders/RawVertical.ts":
/*!************************************!*\
  !*** ./src/Shaders/RawVertical.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'precision highp float;\\nprecision highp int;\\n\\nattribute vec3 position;\\nattribute vec2 uv;\\nvarying vec2 vUv;\\n\\nvoid main() {\\n\\tvUv = uv;\\n\\tgl_Position = vec4(position, 1.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/RawVertical.ts?");

/***/ }),

/***/ "./src/Shaders/ReverseGridFS.ts":
/*!**************************************!*\
  !*** ./src/Shaders/ReverseGridFS.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform sampler2D texture;\\nvarying float brightness;\\nvarying vec2 gUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\t// Additive\\n    gl_FragColor = texture2D( texture, gUV) * brightness;\\n\\n\\t// Subtractive\\n\\t// gl_FragColor = texture2D( texture, gl_PointCoord ) - vec4( color, 1.0 );\\n\\t// gl_FragColor *= opacity;\\n\\n\\t// Multip\\n\\t/* gl_FragColor = -texture2D( texture, gl_PointCoord ) * opacity;\\n\\tgl_FragColor *= 1.0 - vec4( color, 1.0 );\\n\\tgl_FragColor += 1.0; */\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/ReverseGridFS.ts?");

/***/ }),

/***/ "./src/Shaders/VerticalShader.ts":
/*!***************************************!*\
  !*** ./src/Shaders/VerticalShader.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define PI 3.1415926\\n\\nattribute float diagonal;\\n\\nuniform sampler2D heightmap;\\nuniform float vpH;\\nuniform vec2 origin;\\nuniform float prog;\\n\\nvarying float opacity;\\nvarying float diag;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n\\treturn max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\tdiag = diagonal;\\n\\tfloat fluctuation = -texture2D(heightmap, uv).r;\\n\\n\\t// Endless threadmill\\n\\tvec3 newPos = position;\\n\\tnewPos.xz -= origin;\\n\\tnewPos.x = (fract((newPos.x + RANGE) / RANGE2) * RANGE2) - RANGE;\\n\\tnewPos.z = (fract((newPos.z + RANGE) / RANGE2) * RANGE2) - RANGE;\\n\\tnewPos.y = fluctuation * 0.5;\\n\\n\\t// Size\\n\\tfloat size = normFloat(abs(cameraPosition.y), -0.5, 2.0) * 0.25;\\n\\n\\t// Fade out as camera fog\\n\\tfloat distOrigin = distance(newPos.xz, vec2(-0.5, 0.0));\\n\\topacity = (fluctuation + 0.5) * normFloat(distOrigin, RANGE, RANGE * 0.5);\\n\\n\\t// Make logo\\n\\tfloat ffLogo = step(distOrigin, 1.7) * prog;\\n\\t//newPos.y = max(ffLogo * 0.5, newPos.y);\\n\\topacity = max(ffLogo, opacity);\\n\\tsize = max(ffLogo, size);\\n\\n\\t// Position, size    \\n\\tvec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\tgl_PointSize = vpH * size / -mvPosition.z;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/VerticalShader.ts?");

/***/ }),

/***/ "./src/Shaders/headgridFS.ts":
/*!***********************************!*\
  !*** ./src/Shaders/headgridFS.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define RED vec3(1.0, 0.1, 0.1) // red\\n#define AMB vec3(1.0, 0.6, 0.1)\\t// amber\\n#define WHT vec3(1.0, 1.0, 1.0)\\t// white\\n\\nvarying float wht;\\nvarying float amb;\\n\\nvoid main() {\\n\\tgl_FragColor = vec4((WHT * wht + AMB * amb), 1.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/headgridFS.ts?");

/***/ }),

/***/ "./src/Shaders/reverseBarVS.ts":
/*!*************************************!*\
  !*** ./src/Shaders/reverseBarVS.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'varying float brightness;\\nvarying vec2 gUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\tgUV = uv;\\n    vec4 realPos = modelMatrix * vec4(position, 1.0);\\n    vec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n    vec3 lightVector = normalize(cameraPosition - realPos.xyz);\\n    float diffuse = dot(realNorm, lightVector);\\n    brightness = normFloat(diffuse, 0.0, 0.5);\\n\\n    vec4 mvPosition = viewMatrix * realPos;\\n    gl_Position = projectionMatrix * mvPosition;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/reverseBarVS.ts?");

/***/ }),

/***/ "./src/Shaders/stopBarVS.ts":
/*!**********************************!*\
  !*** ./src/Shaders/stopBarVS.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'varying float brightness;\\nvarying vec2 vUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\tvUV = uv;\\n    vec4 realPos = modelMatrix * vec4(position, 1.0);\\n    vec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n    vec3 lightVector = normalize(cameraPosition - realPos.xyz);\\n    float diffuse = dot(realNorm, lightVector);\\n    brightness = normFloat(diffuse, 0.0, 0.5);\\n\\n    vec4 mvPosition = viewMatrix * realPos;\\n    gl_Position = projectionMatrix * mvPosition;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/stopBarVS.ts?");

/***/ }),

/***/ "./src/Shaders/tailGridFS.ts":
/*!***********************************!*\
  !*** ./src/Shaders/tailGridFS.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define RED vec3(1.0, 0.1, 0.1) // red\\n#define AMB vec3(1.0, 0.6, 0.1)\\t// amber\\n#define WHT vec3(1.0, 1.0, 1.0)\\t// white\\n\\nvarying float red;\\nvarying float amb;\\nvarying float wht;\\nvarying float brightness;\\n\\nvoid main() {\\n\\tgl_FragColor = vec4((RED * red + AMB * amb) * brightness, 1.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/tailGridFS.ts?");

/***/ }),

/***/ "./src/Shaders/tailGridVS.ts":
/*!***********************************!*\
  !*** ./src/Shaders/tailGridVS.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define NIGHTLIGHT 0.4\\n\\nfloat normFloat(float n, float minVal, float maxVal){\\n\\treturn max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\n// Returns 1 if type matches val, 0 if not\\nfloat checkType(float type, float val){\\n\\treturn step(val - 0.1, type) * step(type, val + 0.1);\\n}\\n\\nuniform vec3 lightsT;\\nuniform vec3 lightsO;\\nattribute float type;\\nvarying float red;\\nvarying float amb;\\nvarying float wht;\\nvarying float brightness;\\n\\nvoid main(){\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n \\tvec3 realPos = vec3(modelMatrix * vec4(position, 1.0));\\n\\tvec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n\\tvec3 lightVector = normalize(cameraPosition - realPos);\\n\\tbrightness = dot(realNorm, lightVector);\\n\\tbrightness = normFloat(brightness, 0.3, 0.2) + 0.5;\\n\\tbrightness *= brightness * brightness;\\n\\t\\n\\t// Type 0: FF logo\\t\\n\\tred = checkType(type, 0.0);\\n\\t// FF brightens on stop light\\n\\tred += red * lightsO.x;\\n\\n\\t// Type 1: center grid\\n\\tred += checkType(type, 1.0) * NIGHTLIGHT;\\n\\n\\t// Type 2: Right blinker\\n\\tred += (checkType(type, 2.0) * NIGHTLIGHT) * step(lightsT.x, 0.0);\\n\\tamb = checkType(type, 2.0) * lightsT.z;\\n\\n\\t// Type 3: Left blinker\\n\\tred += (checkType(type, 3.0) * NIGHTLIGHT) * step(0.0, lightsT.x);\\n\\tamb += checkType(type, 3.0) * lightsT.y;\\n\\t\\n\\tbrightness = clamp(brightness, 0.0, 1.0);\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/tailGridVS.ts?");

/***/ }),

/***/ "./src/Shaders/tailLightVS.ts":
/*!************************************!*\
  !*** ./src/Shaders/tailLightVS.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = '#define NIGHTLIGHT 0.4\\n\\nfloat normFloat(float n, float minVal, float maxVal){\\n\\treturn max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\n// Returns 1 if type matches val, 0 if not\\nfloat checkType(float type, float val){\\n\\treturn step(val - 0.1, type) * step(type, val + 0.1);\\n}\\n\\nuniform vec3 lightsT;\\nuniform vec3 lightsO;\\nattribute float type;\\nvarying float red;\\nvarying float amb;\\nvarying float wht;\\nvarying float brightness;\\n\\nvoid main(){\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\tbrightness = 1.0;\\n\\n\\t// Type 0: Reverse light?\\n\\tamb = checkType(type, 0.0) * lightsO.x;\\n\\t// Type 1: Right blinker\\n\\tamb += checkType(type, 1.0) * lightsT.z;\\n\\n\\t// Type 2: Left blinker\\n\\tamb += checkType(type, 2.0) * lightsT.y;\\n\\n\\t// Type 3: Side brakelights & side nightlights\\n\\tred = checkType(type, 3.0) * (NIGHTLIGHT + lightsO.x * (1.0 - NIGHTLIGHT));\\n\\n\\t// Type 4: Center brakelight\\n\\tred += checkType(type, 4.0) * lightsO.x;\\n\\n\\t// Type 5: Center nightlight\\n\\tred += checkType(type, 5.0) * NIGHTLIGHT;\\n\\n\\t// Type 6: Lower foglights off\\n\\tred += checkType(type, 6.0) * NIGHTLIGHT * 0.2;\\n\\n\\t// Type 7: Lower foglights on\\n\\tred += checkType(type, 7.0) * NIGHTLIGHT * 1.5;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/tailLightVS.ts?");

/***/ }),

/***/ "./src/Shaders/turnBarFS.ts":
/*!**********************************!*\
  !*** ./src/Shaders/turnBarFS.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform sampler2D texture;\\nvarying float brightness;\\nvarying vec2 vUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\t// Additive\\n    gl_FragColor = texture2D( texture, vUV) * brightness;\\n\\n\\t// Subtractive\\n\\t// gl_FragColor = texture2D( texture, gl_PointCoord ) - vec4( color, 1.0 );\\n\\t// gl_FragColor *= opacity;\\n\\n\\t// Multip\\n\\t/* gl_FragColor = -texture2D( texture, gl_PointCoord ) * opacity;\\n\\tgl_FragColor *= 1.0 - vec4( color, 1.0 );\\n\\tgl_FragColor += 1.0; */\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/turnBarFS.ts?");

/***/ }),

/***/ "./src/Shaders/turnBarVS.ts":
/*!**********************************!*\
  !*** ./src/Shaders/turnBarVS.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 'uniform vec3 lightsT;\\nvarying float brightness;\\nvarying vec2 vUV;\\n\\n// Normalizes a value between 0 - 1\\nfloat normFloat(float n, float minVal, float maxVal){\\n    return max(0.0, min(1.0, (n-minVal) / (maxVal-minVal)));\\n}\\n\\nvoid main() {\\n\\tvUV = uv;\\n    vec4 realPos = modelMatrix * vec4(position, 1.0);\\n    vec3 realNorm = normalize(vec3(modelMatrix * vec4(normal, 0.0)));\\n\\n    vec3 lightVector = normalize(cameraPosition - realPos.xyz);\\n    float diffuse = dot(realNorm, lightVector);\\n    brightness = step(2000.0, position.y) * lightsT.z + step(position.y, 2000.0) * lightsT.y;\\n    brightness *= normFloat(diffuse, 0.0, 0.5);\\n\\n    vec4 mvPosition = viewMatrix * realPos;\\n    gl_Position = projectionMatrix * mvPosition;\\n}';\n\n//# sourceURL=webpack:///./src/Shaders/turnBarVS.ts?");

/***/ }),

/***/ "./src/Utility/Binocs.ts":
/*!*******************************!*\
  !*** ./src/Utility/Binocs.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Binocs = function () {\r\n  function Binocs(options) {\r\n    this.options = {\r\n      distance: 90,\r\n      focusPos: new THREE.Vector3(),\r\n      rotation: new THREE.Vector3(),\r\n      distRange: {\r\n        max: Number.POSITIVE_INFINITY,\r\n        min: Number.NEGATIVE_INFINITY\r\n      },\r\n      fov: 45,\r\n      eyeSeparation: 1.5\r\n    };\r\n    for (var key in options) {\r\n      if (key === 'distRange') {\r\n        for (var key in options.distRange) {\r\n          this.options.distRange[key] = options.distRange[key];\r\n        }\r\n      } else {\r\n        this.options[key] = options[key];\r\n      }\r\n    }\r\n    this.distActual = this.options.distance;\r\n    this.distTarget = this.options.distance;\r\n    this.focusActual = this.options.focusPos.clone();\r\n    this.focusTarget = this.options.focusPos.clone();\r\n    this.rotActual = this.options.rotation.clone();\r\n    this.rotTarget = this.options.rotation.clone();\r\n    this.vpW = window.innerWidth;\r\n    this.vpH = window.innerHeight;\r\n    this.binoculars = new THREE.Object3D();\r\n    this.lensL = new THREE.PerspectiveCamera(this.options.fov, this.vpW / 2 / this.vpH, 0.1, 100);\r\n    this.lensR = new THREE.PerspectiveCamera(this.options.fov, this.vpW / 2 / this.vpH, 0.1, 100);\r\n    this.lensL.position.setX(-this.options.eyeSeparation / 2);\r\n    this.lensR.position.setX(this.options.eyeSeparation / 2);\r\n    this.binoculars.add(this.lensL);\r\n    this.binoculars.add(this.lensR);\r\n    this.radians = Math.PI / 180;\r\n    this.quatX = new THREE.Quaternion();\r\n    this.quatY = new THREE.Quaternion();\r\n    this.gyro = { orient: 0 };\r\n    if (typeof window.orientation !== 'undefined') {\r\n      this.defaultEuler = new THREE.Euler(90 * this.radians, 180 * this.radians, (180 + parseInt(window.orientation.toString(), 10)) * this.radians);\r\n    } else {\r\n      this.defaultEuler = new THREE.Euler(0, 0, 0);\r\n    }\r\n    this.addVignette();\r\n  }\r\n  Binocs.prototype.addVignette = function () {\r\n    var outer = 0.05;\r\n    var edge = outer * 0.8;\r\n    var corner = outer * 0.75;\r\n    var shape = new THREE.Shape();\r\n    shape.moveTo(-outer, -outer);\r\n    shape.lineTo(outer, -outer);\r\n    shape.lineTo(outer, outer);\r\n    shape.lineTo(-outer, outer);\r\n    shape.closePath();\r\n    var hole = new THREE.Path();\r\n    hole.moveTo(-corner, -corner);\r\n    hole.bezierCurveTo(-edge, 0, -edge, 0, -corner, corner);\r\n    hole.bezierCurveTo(0, edge, 0, edge, corner, corner);\r\n    hole.bezierCurveTo(edge, 0, edge, 0, corner, -corner);\r\n    hole.bezierCurveTo(0, -edge, 0, -edge, -corner, -corner);\r\n    shape.holes.push(hole);\r\n    this.vigGeom = new THREE.ShapeGeometry(shape, 6);\r\n    this.vigMat = new THREE.MeshBasicMaterial({\r\n      color: 0x000000,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true\r\n    });\r\n    this.vignetteL = new THREE.Mesh(this.vigGeom, this.vigMat);\r\n    this.vignetteR = this.vignetteL.clone();\r\n    this.vignetteL.position.set(-this.options.eyeSeparation / 2, 0, -0.11);\r\n    this.vignetteR.position.set(this.options.eyeSeparation / 2, 0, -0.11);\r\n    this.vignetteL.scale.set(this.vpW / 2 / this.vpH, 1, 1);\r\n    this.vignetteR.scale.set(this.vpW / 2 / this.vpH, 1, 1);\r\n    this.binoculars.add(this.vignetteL);\r\n    this.binoculars.add(this.vignetteR);\r\n  };\r\n  Binocs.prototype.setDistance = function (dist) {\r\n    if (dist === void 0) {\r\n      dist = 150;\r\n    }\r\n    this.distActual = dist;\r\n    this.distTarget = dist;\r\n  };\r\n  Binocs.prototype.setRotation = function (_rotX, _rotY, _rotZ) {\r\n    if (_rotX === void 0) {\r\n      _rotX = 0;\r\n    }\r\n    if (_rotY === void 0) {\r\n      _rotY = 0;\r\n    }\r\n    if (_rotZ === void 0) {\r\n      _rotZ = 0;\r\n    }\r\n    this.rotActual.set(_rotX, _rotY, _rotZ);\r\n    this.rotTarget.set(_rotX, _rotY, _rotZ);\r\n    this.gyro.alpha = undefined;\r\n    this.gyro.beta = undefined;\r\n    this.gyro.gamma = undefined;\r\n  };\r\n  Binocs.prototype.setFocusPos = function (_posX, _posY, _posZ) {\r\n    if (_posX === void 0) {\r\n      _posX = 0;\r\n    }\r\n    if (_posY === void 0) {\r\n      _posY = 0;\r\n    }\r\n    if (_posZ === void 0) {\r\n      _posZ = 0;\r\n    }\r\n    this.focusActual.set(_posX, _posY, _posZ);\r\n    this.focusTarget.set(_posX, _posY, _posZ);\r\n  };\r\n  Binocs.prototype.dolly = function (distance) {\r\n    this.distTarget += distance / 100;\r\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\r\n  };\r\n  Binocs.prototype.orbitBy = function (angleX, angleY) {\r\n    this.rotTarget.x += angleX;\r\n    this.rotTarget.y += angleY;\r\n  };\r\n  Binocs.prototype.orbitTo = function (angleX, angleY) {\r\n    this.rotTarget.x = angleX;\r\n    this.rotTarget.y = angleY;\r\n  };\r\n  Binocs.prototype.pan = function (distX, distY) {\r\n    this.focusTarget.x -= distX / 10;\r\n    this.focusTarget.y += distY / 10;\r\n  };\r\n  Binocs.prototype.onWindowResize = function (vpW, vpH) {\r\n    this.vpW = vpW;\r\n    this.vpH = vpH;\r\n    this.lensL.aspect = this.vpW / 2 / this.vpH;\r\n    this.lensL.updateProjectionMatrix();\r\n    this.lensR.aspect = this.vpW / 2 / this.vpH;\r\n    this.lensR.updateProjectionMatrix();\r\n    this.vignetteL.scale.set(this.vpW / 2 / this.vpH, 1, 1);\r\n    this.vignetteR.scale.set(this.vpW / 2 / this.vpH, 1, 1);\r\n  };\r\n  Binocs.prototype.onDeviceReorientation = function (orientation) {\r\n    this.gyro.orient = orientation * this.radians;\r\n  };\r\n  Binocs.prototype.onGyroMove = function (alpha, beta, gamma) {\r\n    var acc = this.gyro;\r\n    acc.alpha = alpha;\r\n    acc.beta = beta;\r\n    acc.gamma = gamma;\r\n  };\r\n  Binocs.prototype.update = function () {\r\n    this.distTarget = THREE.Math.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\r\n    this.distActual += (this.distTarget - this.distActual) * 0.01;\r\n    this.focusActual.lerp(this.focusTarget, 0.05);\r\n    this.binoculars.position.copy(this.focusActual);\r\n    if (this.gyro.alpha && this.gyro.beta && this.gyro.gamma) {\r\n      this.binoculars.setRotationFromEuler(this.defaultEuler);\r\n      this.binoculars.rotateZ(this.gyro.alpha * this.radians);\r\n      this.binoculars.rotateX(this.gyro.beta * this.radians);\r\n      this.binoculars.rotateY(this.gyro.gamma * this.radians);\r\n      this.binoculars.rotation.z += this.gyro.orient;\r\n    } else {\r\n      this.rotActual.lerp(this.rotTarget, 0.05);\r\n      this.quatX.setFromAxisAngle(Binocs.axisX, -THREE.Math.degToRad(this.rotActual.y));\r\n      this.quatY.setFromAxisAngle(Binocs.axisY, -THREE.Math.degToRad(this.rotActual.x));\r\n      this.quatY.multiply(this.quatX);\r\n      this.binoculars.quaternion.copy(this.quatY);\r\n    }\r\n    this.binoculars.translateZ(this.distActual);\r\n  };\r\n  Binocs.prototype.renderStereo = function (renderer, scene) {\r\n    renderer.setScissor(0, 0, this.vpW / 2, this.vpH);\r\n    renderer.setViewport(0, 0, this.vpW / 2, this.vpH);\r\n    renderer.render(scene, this.lensL);\r\n    renderer.setScissor(this.vpW / 2, 0, this.vpW / 2, this.vpH);\r\n    renderer.setViewport(this.vpW / 2, 0, this.vpW / 2, this.vpH);\r\n    renderer.render(scene, this.lensR);\r\n  };\r\n  Binocs.axisX = new THREE.Vector3(1, 0, 0);\r\n  Binocs.axisY = new THREE.Vector3(0, 1, 0);\r\n  return Binocs;\r\n}();\r\nexports.default = Binocs;\n\n//# sourceURL=webpack:///./src/Utility/Binocs.ts?");

/***/ }),

/***/ "./src/Utility/Raycaster.ts":
/*!**********************************!*\
  !*** ./src/Utility/Raycaster.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Ray = function () {\r\n  function Ray(_cam) {\r\n    this.cam = _cam;\r\n    this.ray = new THREE.Raycaster();\r\n\r\n    this.geom = new THREE.PlaneBufferGeometry(64, 64);\r\n    this.geom.rotateX(-Math.PI / 2);\r\n\r\n    this.mat = new THREE.MeshStandardMaterial();\r\n    this.plane = new THREE.Mesh(this.geom, this.mat);\r\n  }\r\n  \r\n  Ray.prototype.rayCast = function (mouse) {\r\n    this.ray.setFromCamera(mouse, this.cam);\r\n    \r\n    var intersects = this.ray.intersectObject(this.plane);\r\n\r\n    if (typeof intersects[0] !== 'undefined') {\r\n      return intersects[0].point;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return Ray;\r\n\r\n}();\r\n\r\nexports.default = Ray;\n\n//# sourceURL=webpack:///./src/Utility/Raycaster.ts?");

/***/ }),

/***/ "./src/Utility/RippleGenerator.ts":
/*!****************************************!*\
  !*** ./src/Utility/RippleGenerator.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar rawVert = __webpack_require__(/*! ../Shaders/RawVertical */ \"./src/Shaders/RawVertical.ts\");\r\nvar hmFrag = __webpack_require__(/*! ../Shaders/HMFragment */ \"./src/Shaders/HMFragment.ts\");\r\n\r\nvar RippleGen = function () {\r\n  function RippleGen(_renderer, mouse, _gridSize) {\r\n    if (_gridSize === void 0) {\r\n      _gridSize = 64;\r\n    }\r\n\r\n    this.renderChange = false;\r\n    this.devMode = false;\r\n    this.renderer = _renderer;\r\n    this.textureSize = _gridSize;\r\n\r\n    var dataType = /(iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\r\n\r\n    this.rTarget1 = new THREE.WebGLRenderTarget(this.textureSize, this.textureSize, {\r\n      minFilter: THREE.NearestFilter,\r\n      magFilter: THREE.NearestFilter,\r\n      stencilBuffer: false,\r\n      depthBuffer: false,\r\n      format: THREE.RGBAFormat,\r\n      type: dataType,\r\n      wrapS: THREE.RepeatWrapping,\r\n      wrapT: THREE.RepeatWrapping\r\n    });\r\n\r\n    this.rTarget2 = this.rTarget1.clone();\r\n    this.gpScene = new THREE.Scene();\r\n    this.gpCam = new THREE.Camera();\r\n    this.gpCam.position.z = 1;\r\n\r\n    var rezString = 'vec2( ' + this.textureSize.toFixed(1) + ', ' + this.textureSize.toFixed(1) + ' )';\r\n\r\n    this.gpGeom = new THREE.PlaneBufferGeometry(2, 2);\r\n    this.gpMat = new THREE.RawShaderMaterial({\r\n      uniforms: {\r\n        ripplePos: {\r\n          value: mouse\r\n        },\r\n        rippleSize: {\r\n          value: 1\r\n        },\r\n        rippleImpact: {\r\n          value: 1\r\n        },\r\n        viscosity: {\r\n          value: 0.01\r\n        },\r\n        heightmap: {\r\n          value: null\r\n        }\r\n      },\r\n      defines: {\r\n        BOUNDS: this.textureSize.toFixed(1),\r\n        resolution: rezString\r\n      },\r\n      vertexShader: rawVert,\r\n      fragmentShader: hmFrag,\r\n      depthWrite: false\r\n    });\r\n\r\n    this.uniSize = this.gpMat.uniforms['rippleSize'];\r\n    this.uniImpact = this.gpMat.uniforms['rippleImpact'];\r\n    this.gpMesh = new THREE.Mesh(this.gpGeom, this.gpMat);\r\n    this.gpScene.add(this.gpMesh);\r\n\r\n    if (this.devMode) {\r\n      this.devScene = new THREE.Scene();\r\n      this.devCam = new THREE.Camera();\r\n      this.devCam.position.z = 1;\r\n      this.devGeom = new THREE.PlaneBufferGeometry(2, 2);\r\n      this.devMat = new THREE.MeshBasicMaterial({\r\n        map: this.rTarget1.texture\r\n      });\r\n      this.devMesh = new THREE.Mesh(this.devGeom, this.devMat);\r\n      this.devScene.add(this.devMesh);\r\n    }\r\n  }\r\n\r\n  RippleGen.prototype.newRippleSize = function (_size) {\r\n    this.uniSize.value = _size;\r\n  };\r\n\r\n  RippleGen.prototype.newRippleImpact = function (_val) {\r\n    this.uniImpact.value = _val;\r\n  };\r\n\r\n  RippleGen.prototype.update = function () {\r\n    this.renderChange = !this.renderChange;\r\n    if (this.renderChange) {\r\n      this.gpMat.uniforms['heightmap'].value = this.rTarget2.texture;\r\n      this.renderer.render(this.gpScene, this.gpCam, this.rTarget1);\r\n\r\n      if (this.devMode) {\r\n        this.renderer.setViewport(0, 0, this.textureSize * 2, this.textureSize * 2);\r\n        this.renderer.render(this.devScene, this.devCam);\r\n        this.renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);\r\n      }\r\n\r\n      return this.rTarget1.texture;\r\n    } else {\r\n      this.gpMat.uniforms['heightmap'].value = this.rTarget1.texture;\r\n      this.renderer.render(this.gpScene, this.gpCam, this.rTarget2);\r\n\r\n      if (this.devMode) {\r\n        this.renderer.setViewport(0, 0, this.textureSize * 2, this.textureSize * 2);\r\n        this.renderer.render(this.devScene, this.devCam);\r\n        this.renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);\r\n      }\r\n\r\n      return this.rTarget2.texture;\r\n    }\r\n  };\r\n\r\n  return RippleGen;\r\n}();\r\n\r\nexports.default = RippleGen;\n\n//# sourceURL=webpack:///./src/Utility/RippleGenerator.ts?");

/***/ }),

/***/ "./src/Utility/Utils.ts":
/*!******************************!*\
  !*** ./src/Utility/Utils.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nfunction normalize(val, min, max) {\r\n  return Math.max(0, Math.min(1, (val - min) / (max - min)));\r\n}\r\n\r\nexports.normalize = normalize;\r\n\r\nfunction normalizeQuadIn(val, min, max) {\r\n  return Math.pow(normalize(val, min, max), 2);\r\n}\r\n\r\nexports.normalizeQuadIn = normalizeQuadIn;\r\n\r\nfunction normalizeQuadOut(val, min, max) {\r\n  var x = normalize(val, min, max);\r\n  return x * (2 - x);\r\n}\r\n\r\nexports.normalizeQuadOut = normalizeQuadOut;\r\n\r\nfunction zTween(_val, _target, _ratio) {\r\n  return _val + (_target - _val) * Math.min(_ratio, 1);\r\n}\r\n\r\nexports.zTween = zTween;\r\n\r\nvar Time = function () {\r\n  function Time(timeFactor) {\r\n    this.fallBackRates = [\r\n      60,\r\n      40,\r\n      30,\r\n      20,\r\n      15\r\n    ];\r\n\r\n    this.prev = 0;\r\n    this.prevBreak = 0;\r\n    this.delta = 0;\r\n    this.timeFact = typeof timeFactor === 'undefined' ? 1 : timeFactor;\r\n    this.frameCount = 0;\r\n    this.fallBackIndex = 0;\r\n\r\n    this.setFPS(60);\r\n  }\r\n\r\n  Time.prototype.update = function (_newTime) {\r\n    this.deltaBreak = Math.min(_newTime - this.prevBreak, 1);\r\n\r\n    if (this.deltaBreak > this.spf) {\r\n      this.delta = Math.min(_newTime - this.prev, 1);\r\n      this.prev = _newTime;\r\n      this.prevBreak = _newTime - this.deltaBreak % this.spf;\r\n      \r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  Time.prototype.checkFPS = function () {\r\n    if (this.delta > this.spf * 2) {\r\n      this.frameCount++;\r\n\r\n      console.log(this.frameCount);\r\n\r\n      if (this.frameCount > 30) {\r\n        this.frameCount = 0;\r\n        this.fallBackIndex++;\r\n\r\n        this.setFPS(this.fallBackRates[this.fallBackIndex]);\r\n      }\r\n    }\r\n  };\r\n\r\n  Time.prototype.setFPS = function (_newVal) {\r\n    this.fps = _newVal;\r\n    this.spf = 1 / this.fps;\r\n  };\r\n  \r\n  return Time;\r\n}();\r\n\r\nexports.Time = Time;\r\n\r\nfunction shuffle(array) {\r\n  var m = array.length,\r\n    t, i;\r\n\r\n  while (m) {\r\n    i = Math.floor(Math.random() * m--);\r\n    t = array[m];\r\n    array[m] = array[i];\r\n    array[i] = t;\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nexports.shuffle = shuffle;\r\n\r\nfunction mod(n, m) {\r\n  return (n % m + m) % m;\r\n}\r\n\r\nexports.mod = mod;\n\n//# sourceURL=webpack:///./src/Utility/Utils.ts?");

/***/ })

/******/ });